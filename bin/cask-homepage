#!/usr/bin/env bash
#
# Check homepages of the casks and try to fix them using provided rules.
#
# Version:         0.4.2
# License:         MIT License
# Author:          Victor Popkov <victor@popkov.me>
# Last modified:   26.11.2016

# Getting this script's absoute path even when dealing with multi-level symlinks
SOURCE="${BASH_SOURCE[0]}"
DIR=$(dirname "${SOURCE}")
while [ -h "${SOURCE}" ]; do
  SOURCE=$(readlink "${SOURCE}")
  [[ ${SOURCE} != /* ]] && SOURCE="${DIR}/${SOURCE}"
  DIR="$(cd -P "$(dirname "${SOURCE}")" && pwd)"
done
readonly SOURCE DIR

# Constants and globals
readonly VERSION='0.4.2'
readonly BASE_PATH="$(cd "${DIR}/.." && pwd)"
readonly PROGRAM=$(basename "$0")
readonly CONFIG_FILE_XML="${BASE_PATH}/lib/cask-scripts/config/cask-homepage.xml"
declare -a CASKS
declare -a RULES
declare -a RULES_ENABLED
declare -a RULES_DISABLED
declare -i FIX_TOTAL
declare -i FIXED_TOTAL
BROWSER_HEADERS='User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/33.0.1750.152 Safari/537.36'
REMOTE_PULL='upstream'
REMOTE_PUSH='origin'
BRANCH_NAME=''
DELETE_BRANCHES='false'
OUTPUT='false'
OUTPUT_PATH=''
RULES=('bare_slash' 'host' 'http' 'https' 'path' 'slash' 'no_slash' 'www' 'no_www')
FIX='false'
FIX_TOTAL=0
FIXED_TOTAL=0
SHOW_ALL='false'
EDIT='false'

# shellcheck source=/dev/null
source "${BASE_PATH}/lib/cask-scripts/general.bash"
# shellcheck source=/dev/null
source "${BASE_PATH}/lib/cask-scripts/url.bash"
# shellcheck source=/dev/null
source "${BASE_PATH}/lib/cask-scripts/cask.bash"
# shellcheck source=/dev/null
source "${BASE_PATH}/lib/cask-scripts/git.bash"

# Display help.
#
# Globals:
#   PROGRAM
usage() {
  echo "usage: ${PROGRAM} [options] [<casks>...]

    Check homepages of the casks and try to fix them using provided rules:

      bare_slash   Missing a bare domain URL trailing slash
      host         Host has changed
      http         Only HTTP is available
      https        HTTPS is available
      no_slash     Server prefers to exclude a trailing slash
      no_www       Server prefers to exclude www
      path         Path has changed
      slash        Server prefers to include a trailing slash
      www          Server prefers to include www

    options:
      -l, --pull <remote>        Use to specify a remote to pull from (defaults to 'upstream').
      -p, --push <remote>        Use to specify a remote to push to (defaults to 'origin').
      -b, --push-branch <name>   Use to specify a branch name to push to (generated by default).
      -e, --push-edit            Edit pushed changes.
      -i, --ignore <rules>       Ignore specified rules separated by a comma.
                                 Example: '${PROGRAM} -i http,https,www [<casks>...]'
      -H, --header <header>      Set browser header.
      -o, --output <filepath>    Output the results in CSV format into a file.
      -f, --fix (<total>)        Try to fix warnings automatically (optional: a total number of casks to fix).
      -a, --all                  Show and output all casks even if homepages are good.
      -d, --delete-branches      Deletes local and remote branch named '${PROGRAM}_*'.
      -v, --version              Show current script version.
      -h, --help                 Show this help." | sed -E 's/^ {4}//'
}

# available flags
while [[ "$1" ]]; do
  case "$1" in
    -l | --pull)
      REMOTE_PULL="$2"
      shift
      ;;
    -p | --push)
      REMOTE_PUSH="$2"
      shift
      ;;
    -b | --push-branch)
      BRANCH_NAME="$2"
      shift
      ;;
    -e | --push-edit)
      readonly EDIT='true'
      ;;
    -i | --ignore)
      IFS=$',' read -rd '' -a RULES_DISABLED <<< "$2"
      [[ -z "$2" ]] && syntax_error 'Please specify the rule(s) to ignore'
      for rule in "${RULES_DISABLED[@]}"; do
        rule=$(echo -n "${rule}" | xargs)
        check_array_contains 'RULES[@]' "${rule}" || syntax_error "Rule '${rule}' doesn't exist"
      done
      shift
      ;;
    -H | --header)
      readonly BROWSER_HEADERS="$2"
      shift
      ;;
    -o | --output)
      readonly OUTPUT='true'
      readonly OUTPUT_PATH="$2"
      shift
      ;;
    -f | --fix)
      FIX='true'
      FIX_TOTAL="$2"
      if [[ "${FIX_TOTAL}" != 0 ]]; then
        shift
      fi
      ;;
    -a | --all)
      SHOW_ALL='true'
      ;;
    -d | --delete-branches)
      DELETE_BRANCHES='true'
      ;;
    -v | --version)
      version
      ;;
    -h | --help)
      usage
      exit 0
      ;;
    -*)
      syntax_error "unrecognized option: $1"
      ;;
    *)
      for arg in "$@"; do
        cask="${arg/.rb}"
        [[ -f "${cask}.rb" ]] && CASKS+=("${cask}") || printf "Cask '%s' not found\n" "${cask}"
      done
      [[ "$#" != "${#CASKS[@]}" ]] && [[ "${#CASKS[@]}" -eq 0 ]] && exit 1

      readonly SHOW_ALL='true'
      break
      ;;
  esac
  shift
done

# check if in correct directory
if ! pwd | grep -q 'homebrew-.*/Casks'; then
  error "You need to be inside a '/homebrew-*/Casks' directory"
fi

# Check if specified rule is enabled.
#
# Globals:
#   RULES_ENABLED
#
# Arguments:
#   $1 - Rule
#
# Returns:
#   0 – Enabled
#   1 – Disabled
check_rule_enabled() {
  check_array_contains 'RULES_ENABLED[@]' "$1"
}

# Append new line to CSV file.
#
# Globals:
#   OUTPUT
#   OUTPUT_PATH
#
# Arguments:
#   $1 - Cask name
#   $2 - Homepage
#   $3 - Response code
#   $4 - Status
#   $5 - Warnings
#   $6 - Fixed
output_csv() {
  [[ "${OUTPUT}" == 'true' ]] && printf "\"%s\";\"%s\";\"%s\";\"%s\";\"%s\";\"%s\"\n" "$1" "$2" "$3" "$4" "$5" "$6" >> "${OUTPUT_PATH}"
}

# Review URL using provided method name.
#
# Used external variables:
#   fixed
#   warnings
#   cask
#
# Arguments:
#   $1 - Warning rule
#   $2 - Message
#   $3 - URL
#   $4 - Redirect
review_url() {
  local -a config_rules
  local method rule msg url redirect fixed_new

  readonly rule="$1"
  readonly msg="$2"
  readonly url="$3"
  readonly redirect="$4"
  [[ -z "${rule}" ]] || [[ -z "${msg}" ]] || [[ -z "${url}" ]] || [[ -z "${redirect}" ]] && return 1

  readonly method="url_fix_${rule}"

  # cask specific ignore rule
  config_rules=($(get_xml_config_values "//ignore/${rule}/casks" 'cask'))
  for r in "${config_rules[@]}"; do
    [[ "${cask}" == "${r}" ]] && return 1
  done

  # URL specific ignore rule
  config_rules=($(get_xml_config_values "//ignore/${rule}/urls" 'url'))
  for r in "${config_rules[@]}"; do
    [[ "${url}" =~ ${r} ]] && return 1
  done

  fixed_new=$(${method} "${url}" "${redirect}")
  if [[ ! -z "${fixed_new}" ]] && [[ "${fixed}" != "${fixed_new}" ]]; then
    fixed="${fixed_new}"
    warnings+=("${rule}")
    add_warning_to_review "${msg} → $(highlight_diff "${url}" "${fixed}")"
  fi

  return 0
}

# Create homepage review for specified cask.
#
# Globals:
#   RULES_DISABLED
#   REVIEW_WARNINGS
#   SHOW_ALL
#   FIX
#   FIXED_TOTAL
#
# Arguments:
#   $1 - Cask name
review_homepage() {
  local -a warnings config_rules
  local -i code code_color status status_color
  local cask homepage homepage_path homepage_redirect homepage_redirect_path host redirect_host out rule skip status_msg fixed warnings_str

  readonly cask="$1"
  readonly homepage=$(get_cask_stanza_value "${cask}" 'homepage')
  readonly homepage_path=$(get_url_path "${homepage}")
  readonly host=$(get_url_host "${homepage}")
  readonly out=$(get_url_status "${homepage}")
  readonly code=$(echo "${out}" | head -n 1)
  readonly status=$(echo "${out}" | tail -n 1)
  [[ -z "${fixed}" ]] && fixed="${homepage}"

  # skip a cask if defined in config
  config_rules=($(get_xml_config_values '//skip/casks' 'cask'))
  check_array_contains 'config_rules' "${cask}" && skip='true' || skip='false'
  readonly skip

  [[ "${code}" -eq 200 ]] && code_color=2 || code_color=3

  if [[ "${skip}" == 'true' ]]; then
    status_color=7
    status_msg='skipped'
  elif [[ "${skip}" == 'false' ]]; then
    if [[ "${status}" -eq 0 ]]; then
      # success
      readonly homepage_redirect=$(get_url_redirect "${homepage}")
      readonly homepage_redirect_path=$(get_url_path "${homepage_redirect}")
      readonly redirect_host=$(get_url_host "${homepage_redirect}")

      check_rule_enabled 'host'       && review_url 'host'       'Host has changed'                           "${fixed}" "${homepage_redirect}"
      check_rule_enabled 'path'       && review_url 'path'       'Path has changed'                           "${fixed}" "${homepage_redirect}"
      check_rule_enabled 'http'       && review_url 'http'       'Only HTTP is available'                     "${fixed}" "${homepage_redirect}"
      check_rule_enabled 'https'      && review_url 'https'      'HTTPS is available'                         "${fixed}" "${homepage_redirect}"
      check_rule_enabled 'www'        && review_url 'www'        'Server prefers to include WWW'              "${fixed}" "${homepage_redirect}"
      check_rule_enabled 'no_www'     && review_url 'no_www'     'Server prefers to exclude WWW'              "${fixed}" "${homepage_redirect}"
      check_rule_enabled 'slash'      && review_url 'slash'      'Server prefers to include a trailing slash' "${fixed}" "${homepage_redirect}"
      check_rule_enabled 'no_slash'   && review_url 'no_slash'   'Server prefers to exclude a trailing slash' "${fixed}" "${homepage_redirect}"
      check_rule_enabled 'bare_slash' && review_url 'bare_slash' 'Missing a bare domain URL trailing slash'   "${fixed}" "${homepage_redirect}"

      status_color=2
      status_msg='good'
    else
      # curl returned non 0 status (error)
      status_color=1
      status_msg='error'
      [[ "${status}" -eq 28 ]] && status_msg='error (request timed out)'
    fi
  fi

  if [[ "${#REVIEW_WARNINGS[@]}" -gt 0 ]]; then
    status_color=3
    status_msg='warning'
    warnings_str=$(join_by ', ' "${warnings[@]}")
  fi

  # check if output to CSV is needed
  if [[ "${#warnings[@]}" -gt 0 ]] || [[ "${SHOW_ALL}" == 'true' ]]; then
    # output to CSV
    show='true'
    output_csv "${cask}" "${homepage}" "${code}" "${status_msg}" "$([[ "${#warnings[@]}" -gt 0 ]] && echo "${warnings_str}" || echo '-')" "$([[ ! -z "${fixed}" ]] && echo "${fixed}" || echo '-')"
  fi

  # check if fixing is enabled and available
  if [[ "${FIX}" == 'true' ]] && [[ ! -z "${fixed}" ]]; then
    add_to_review 'Cask homepage' "${homepage} [$(tput setaf "${code_color}")${code}$(tput sgr0)] → $(tput setaf 7)${fixed}$(tput sgr0) [$(tput setaf 2)200$(tput sgr0)]"
    # fix
    FIXED_TOTAL+=1
    modify_stanza "${cask}" 'homepage' "'${fixed}'"
    git commit "${cask}.rb" --message "Update ${cask} homepage (${warnings_str})" --quiet
    status_color=2
    status_msg='fixed'
  else
    add_to_review 'Cask homepage' "${homepage} [$(tput setaf "${code_color}")${code}$(tput sgr0)]"
  fi

  add_to_review 'Status' "$(tput setaf "${status_color}")${status_msg}$(tput sgr0)"
}

# Prints rule with status.
#
# Arguments:
#   $1 - Rule
#   $2 - Description
print_rule() {
  local rule description enabled disabled

  readonly rule="$1"
  readonly description="$2"
  readonly enabled="$(tput setaf 2)enabled$(tput sgr0)"
  readonly disabled="$(tput setaf 1)disabled$(tput sgr0)"

  printf '%-12s %-21s %s\n' "${rule}" "$(check_rule_enabled "${rule}" && echo "${enabled}" || echo "${disabled}")" "${description}"
}

# Finish the script.
#
# Stolen from https://github.com/vitorgalvao/tiny-scripts/blob/master/cask-repair.
#
# Globals:
#   BRANCH_NAME
#
# Arguments:
#   $1 - Status: 'abort' or 'success'
#   $2 - Message
finish() {
  git reset HEAD --hard --quiet
  git checkout master --quiet
  [[ ! -z "${BRANCH_NAME}" ]] && git branch -D "${BRANCH_NAME}" --quiet

  # show message
  if [[ "$1" == 'abort' ]]; then
    echo -e "\n$(tput setaf 1)$2$(tput sgr0)"
    exit 1
  elif [[ "$1" == 'success' ]]; then
    echo -e "$(tput setaf 2)$2$(tput sgr0)"
    exit 0
  fi
}

# Edit existing pushed changes.
#
# Globals:
#   CASKS
#   REMOTE_PULL
#   REMOTE_PUSH
edit_mode() {
  local -i fixed
  local last_upstream_commit cask commit

  git checkout master --quiet
  ask_remote_branch_to_switch
  git rebase "${REMOTE_PULL}/master" --quiet

  fixed=0
  readonly last_upstream_commit=$(git_get_last_upstream_commit)

  ask_casks_to_edit

  for number in "${!CASKS[@]}"; do
    cask="${CASKS[number]}"
    commit=$(git rev-list -1 HEAD "./${cask}.rb")
    GIT_SEQUENCE_EDITOR="sed -i -e 's/^pick ${commit:0:7}/edit ${commit:0:7}/'" git rebase --interactive "${last_upstream_commit}"

    printf "\033c"
    printf 'Editing cask %i of %i: %s\n' "$((number+1))" "${#CASKS[@]}" "${cask}"

    edit_cask "${cask}"
    fixed+=1

    git add "${cask}.rb"
    git commit --amend
    git rebase --continue
  done

  git_push
  printf "\033c"
  finish success "Pushed ${fixed} casks in branch 'remotes/${REMOTE_PUSH}/${BRANCH_NAME}'..."
}

# cleanup if aborted with ⌃C
trap 'finish abort "You aborted"' SIGINT

# Globals:
#   SHOW_ALL
#   REVIEW_NAMES
#   REVIEW_VALUES
#   CASKS
#   FIX
#   FIX_TOTAL
#
# Arguments:
#   $1 - Cask
main() {
  local cask show

  readonly cask="$1"
  show='false'

  add_to_review 'Cask name' "$(tput setaf 7)${cask}$(tput sgr0)"
  review_homepage "${cask}"
  [[ "${SHOW_ALL}" == 'true' ]] && show='true'
  [[ "${show}" == 'true' ]] && show_review 17

  # shellcheck disable=SC2034
  REVIEW_NAMES=()
  # shellcheck disable=SC2034
  REVIEW_VALUES=()

  [[ "${show}" == 'true' ]] && [[ "${#CASKS[@]}" -gt 1 ]] && divide
}

# preparations
git pull --rebase "${REMOTE_PULL}" master --quiet
git checkout master --quiet
git reset --hard "${REMOTE_PULL}/master" --quiet

# delete branches
if [[ "${DELETE_BRANCHES}" == 'true' ]]; then
  git_delete_program_branches
  exit 0
fi

# edit mode
if [[ "${EDIT}" == 'true' ]]; then
  edit_mode
  exit 0
fi

# fixing (preparations)
if [[ "${FIX}" == 'true' ]]; then
  [[ -z "${BRANCH_NAME}" ]] && BRANCH_NAME="${PROGRAM}_$(random 12)"
  git checkout -b "${BRANCH_NAME}" --quiet
fi

# process
[[ "${#CASKS[@]}" -eq 0 ]] && CASKS=($(egrep -lir --include '*.rb' "(homepage ')" . | xargs -n1 basename | sed 's|\.rb$||' | sort))
printf 'Checking homepages of %i ' "${#CASKS[@]}"
[[ "${#CASKS[@]}" -gt 1 ]] && printf 'casks' || printf 'cask'
printf ' using these rules:\n\n'
[[ "${OUTPUT}" == 'true' ]] && printf "\"%s\";\"%s\";\"%s\";\"%s\";\"%s\";\"%s\"\n" 'Name' 'Homepage' 'Response code' 'Status' 'Warnings' 'Fixed' > "${OUTPUT_PATH}"

for rule in "${RULES[@]}"; do
  rule=$(echo -n "${rule}" | xargs)
  check_array_contains 'RULES_DISABLED[@]' "${rule}" || RULES_ENABLED+=("${rule}")
done

print_rule 'bare_slash' 'Missing a bare domain URL trailing slash'
print_rule 'host'       'Host has changed'
print_rule 'http'       'Only HTTP is available'
print_rule 'https'      'HTTPS is available'
print_rule 'no_slash'   'Server prefers to exclude a trailing slash'
print_rule 'no_www'     'Server prefers to exclude WWW'
print_rule 'path'       'Path has changed'
print_rule 'slash'      'Server prefers to include a trailing slash'
print_rule 'www'        'Server prefers to include WWW'

if [[ "${FIX}" == 'true' ]]; then
  [[ "${FIX_TOTAL}" -gt 0 ]] && printf "\nFixing first %i casks...\n" "${FIX_TOTAL}" || printf '\nFixing all casks...\n'
fi

divide

for cask in "${CASKS[@]}"; do
  [[ "${FIX_TOTAL}" -gt 0 ]] && [[ "${FIXED_TOTAL}" -eq "${FIX_TOTAL}" ]] && break
  main "${cask}"
done

# fixing (push)
if [[ "${FIX}" == 'true' ]]; then
  [[ "${#CASKS[@]}" -eq 1 ]] && divide
  git_push
  finish success "Pushed ${FIXED_TOTAL} casks in branch 'remotes/${REMOTE_PUSH}/${BRANCH_NAME}'..."
fi

exit 0
