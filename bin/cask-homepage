#!/usr/bin/env bash
#
# Check homepages of the casks and try to fix them.
#
# Version:         0.2.11
# License:         MIT License
# Author:          Victor Popkov <victor@popkov.me>
# Last modified:   18.11.2016

# Getting this script's absoute path even when dealing with multi-level symlinks
SOURCE="${BASH_SOURCE[0]}"
DIR=$(dirname "${SOURCE}")
while [ -h "${SOURCE}" ]; do
  SOURCE=$(readlink "${SOURCE}")
  [[ ${SOURCE} != /* ]] && SOURCE="${DIR}/${SOURCE}"
  DIR="$(cd -P "$(dirname "${SOURCE}")" && pwd)"
done
readonly SOURCE DIR

# Constants and globals
readonly VERSION='0.2.11'
readonly BASE_PATH="$(cd "${DIR}/.." && pwd)"
readonly PROGRAM=$(basename "$0")
readonly CONFIG_FILE_XML="${BASE_PATH}/lib/cask-scripts/config/cask-homepage.xml"
declare -a CASKS
declare -a RULES
declare -a RULES_ENABLED
declare -a RULES_DISABLED
declare -i FIX_TOTAL
declare -i FIXED_TOTAL
BROWSER_HEADERS='User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/33.0.1750.152 Safari/537.36'
REMOTE_PULL='upstream'
REMOTE_PUSH='origin'
BRANCH_NAME=''
DELETE_CREATED_BRANCHES='false'
OUTPUT='false'
OUTPUT_PATH=''
RULES=('bare_slash' 'domain' 'http' 'https' 'redirect' 'slash' 'no_slash' 'www' 'no_www')
FIX='false'
FIX_TOTAL=0
FIXED_TOTAL=0
SHOW_ALL='false'

# shellcheck source=/dev/null
source "${BASE_PATH}/lib/cask-scripts/general.bash"
# shellcheck source=/dev/null
source "${BASE_PATH}/lib/cask-scripts/cask.bash"

# Display help.
#
# Globals:
#   PROGRAM
usage() {
  echo "usage: ${PROGRAM} [options] [<casks>...]

    Check homepages of the casks and try to fix them.

    Available rules:

      bare_slash   Missing a bare domain URL trailing slash
      domain       Domain has changed
      http         Only HTTP is available
      https        HTTPS (for new domain) is available
      redirect     Redirect found
      slash        Server prefers to include a trailing slash
      no_slash     Server prefers to exclude a trailing slash
      www          Server prefers to include www
      no_www       Server prefers to exclude www

    options:
      -l, --pull <remote>        Use to specify a remote to pull from (defaults to 'upstream').
      -p, --push <remote>        Use to specify a remote to push to (defaults to 'origin').
      -i, --ignore <rules>       Ignore specified rules separated by a comma.
                                 Example: '${PROGRAM} -i http,https,www [<casks>...]'
      -H, --header <header>      Set browser header.
      -o, --output <filepath>    Output the results in CSV format into a file.
      -f, --fix (<total>)        Try to fix warnings automatically (optional: a total number of casks to fix).
      -a, --all                  Show and output all casks even if homepages are good.
      -d, --delete-branches      Deletes local and remote branch named '${BRANCH_NAME}'.
      -v, --version              Show current script version.
      -h, --help                 Show this help." | sed -E 's/^ {4}//'
}

# available flags
while [[ "$1" ]]; do
  case "$1" in
    -l | --pull)
      REMOTE_PULL="$2"
      shift
      ;;
    -p | --push)
      REMOTE_PUSH="$2"
      shift
      ;;
    -i | --ignore)
      IFS=$',' read -rd '' -a RULES_DISABLED <<< "$2"
      [[ -z "$2" ]] && syntax_error 'Please specify the rule(s) to ignore'
      for rule in "${RULES_DISABLED[@]}"; do
        rule=$(echo -n "${rule}" | xargs)
        check_array_contains 'RULES[@]' "${rule}" || syntax_error "Rule '${rule}' doesn't exist"
      done
      shift
      ;;
    -H | --header)
      readonly BROWSER_HEADERS="$2"
      shift
      ;;
    -o | --output)
      readonly OUTPUT='true'
      readonly OUTPUT_PATH="$2"
      shift
      ;;
    -f | --fix)
      FIX='true'
      FIX_TOTAL="$2"
      if [[ "${FIX_TOTAL}" != 0 ]]; then
        shift
      fi
      ;;
    -a | --all)
      SHOW_ALL='true'
      ;;
    -d | --delete-branches)
      DELETE_CREATED_BRANCHES='true'
      ;;
    -v | --version)
      version
      ;;
    -h | --help)
      usage
      exit 0
      ;;
    -*)
      syntax_error "unrecognized option: $1"
      ;;
    *)
      for arg in "$@"; do
        cask="${arg/.rb}"
        [[ -f "${cask}.rb" ]] && CASKS+=("${cask}") || printf "Cask '%s' not found\n" "${cask}"
      done
      [[ "$#" != "${#CASKS[@]}" ]] && [[ "${#CASKS[@]}" -eq 0 ]] && exit 1

      readonly SHOW_ALL='true'
      break
      ;;
  esac
  shift
done

# check if in correct directory
if ! pwd | grep -q 'homebrew-.*/Casks'; then
  error "You need to be inside a '/homebrew-*/Casks' directory"
fi

# Check if specified rule is enabled.
#
# Globals:
#   RULES_ENABLED
#
# Arguments:
#   $1 - Rule
#
# Returns:
#   0 – Enabled
#   1 – Disabled
check_rule_enabled() {
  check_array_contains 'RULES_ENABLED[@]' "$1"
}

# Append new line to CSV file.
#
# Globals:
#   OUTPUT
#   OUTPUT_PATH
#   SHOW_ALL
#
# Arguments:
#   $1 - Cask name
#   $2 - Homepage
#   $3 - Response code
#   $4 - Status
#   $5 - Warnings
#   $5 - Fixed
output_csv() {
  [[ "${OUTPUT}" == 'true' ]] && printf "\"%s\";\"%s\";\"%s\";\"%s\";\"%s\";\"%s\"\n" "$1" "$2" "$3" "$4" "$5" "$6" >> "${OUTPUT_PATH}"
}

# Create homepage review for specified cask.
#
# Globals:
#   RULES_DISABLED
#   REVIEW_WARNINGS
#   SHOW_ALL
#   FIX
#   FIXED_TOTAL
#
# Arguments:
#   $1 - Cask name
review_homepage() {
  local -a warnings cask_rules
  local -i code code_color status status_color
  local cask homepage homepage_path homepage_redirect homepage_redirect_path host redirect_host out rule skip status_msg fixed warnings_str

  skip='false'
  readonly cask="$1"
  readonly homepage=$(get_cask_stanza_value "${cask}" 'homepage')
  readonly homepage_path=$(get_url_path "${homepage}")
  readonly host=$(get_url_host "${homepage}")
  readonly out=$(get_url_status "${homepage}")
  readonly code=$(echo "${out}" | head -n 1)
  readonly status=$(echo "${out}" | tail -n 1)

  # skip cask if defined in config
  cask_rules=($(get_xml_config_values '//skip' 'cask'))
  for rule in "${cask_rules[@]}"; do
    [[ "${cask}" == "${rule}" ]] && skip='true'
  done

  if [[ "${status}" -eq 0 ]] && [[ "${skip}" == 'false' ]]; then
    # correct status and not skipped
    [[ "${code}" -eq 200 ]] && code_color=2 || code_color=3

    if [[ "${code}" -eq 301 ]] || [[ "${code}" -eq 302 ]]; then
      # redirect found
      readonly homepage_redirect=$(get_url_redirect "${homepage}")
      readonly homepage_redirect_path=$(get_url_path "${homepage_redirect}")
      readonly redirect_host=$(get_url_host "${homepage_redirect}")

      if [[ "${host}" == "${redirect_host}" ]]; then
        # domain not changed
        if check_rule_enabled 'http' && check_url_https "${homepage}" && ! check_url_https "${homepage_redirect}"; then
          # redirects from HTTPS to HTTP
          add_warning_to_review "Only HTTP is available → $(tput setaf 7)http:$(tput sgr0)${homepage/https:}"
          warnings+=('http')
          fixed="http:${homepage/https:}"
        fi

        if check_rule_enabled 'www' && ! check_url_www "${homepage}" && check_url_www "${homepage_redirect}"; then
          # homepage doesn't have www but redirect does
          add_warning_to_review "Server prefers to include www → $(tput setaf 7)${homepage_redirect}$(tput sgr0)"
          warnings+=('www')
          fixed="${homepage_redirect}"
        elif check_rule_enabled 'no_www' && check_url_www "${homepage}" && ! check_url_www "${homepage_redirect}"; then
          # homepage has www but redirect doesn't
          add_warning_to_review "Server prefers to exclude www → $(tput setaf 7)${homepage_redirect}$(tput sgr0)"
          warnings+=('no_www')
          fixed="${homepage_redirect}"
        fi

        if check_rule_enabled 'slash' && [[ "${homepage_path%/}" == "${homepage_redirect_path%/}" ]] && [[ ! "${homepage}" =~ \/$ ]] && [[ "${homepage_redirect}" =~ \/$ ]]; then
          # homepage doesn't have a trailing slash but redirect does
          add_warning_to_review "Server prefers to include a trailing slash → $(highlight "${homepage_redirect}" '\/$' '\/' 7)"
          warnings+=('slash')
          fixed="${homepage_redirect}"
        elif check_rule_enabled 'no_slash' && [[ "${homepage_path%/}" == "${homepage_redirect_path%/}" ]] && [[ "${homepage}" =~ \/$ ]] && [[ ! "${homepage_redirect}" =~ \/$ ]]; then
          # homepage has a trailing slash but doesn't
          add_warning_to_review "Server prefers to exclude a trailing slash → ${homepage_redirect}"
          warnings+=('no_slash')
          fixed="${homepage_redirect}"
        fi

        if [[ "${#warnings[@]}" -eq 0 ]] && check_rule_enabled 'redirect'; then
          add_warning_to_review "Redirect found → $(tput setaf 7)${homepage_redirect}$(tput sgr0)"
          warnings+=('redirect')
          fixed="${homepage_redirect}"
        fi
      elif check_rule_enabled 'domain'; then
        # domain changed
        add_warning_to_review "Domain has changed → $(tput setaf 7)${homepage_redirect}$(tput sgr0)"
        warnings+=('domain')
        fixed="${homepage_redirect}"
      fi
    fi

    status_color=2
    status_msg='good'
  elif [[ "${skip}" == 'true' ]]; then
    # skipped
    [[ "${code}" -eq 200 ]] && code_color=2 || code_color=3
  else
    # curl returned non 0 status (error)
    status_color=1
    status_msg='error'
    [[ "${status}" -eq 28 ]] && status_msg='error (request timed out)'
  fi

  if check_rule_enabled 'https'; then
    # https checking is enabled
    if ! check_array_contains 'warnings[@]' 'domain' && ! check_url_https "${homepage}"; then
      # domain not changed and homepage is using HTTP
      check_url_https_availability "${homepage}"
      if [[ "$?" -eq 0 ]]; then
        add_warning_to_review "HTTPS is available → $(tput setaf 7)https:$(tput sgr0)${homepage/http:}"
        warnings+=('https')
        fixed="https:${homepage/http:}"
      fi
    elif check_array_contains 'warnings[@]' 'domain' && ! check_url_https "${homepage_redirect}"; then
      # domain changed and homepage redirect is using HTTP
      check_url_https_availability "${homepage_redirect}"
      if [[ "$?" -eq 0 ]]; then
        add_warning_to_review "HTTPS for new domain is available → $(tput setaf 7)https:$(tput sgr0)${homepage_redirect/http:}"
        warnings+=('https')
        fixed="https:${homepage_redirect/http:}"
      fi
    fi
  fi

  if check_rule_enabled 'bare_slash'; then
    # bare domain slash checking is enabled
    if [[ ! "${homepage}" =~ ${host}\/ ]]; then
      add_warning_to_review "Missing a bare domain URL trailing slash → ${homepage}$(tput setaf 7)/$(tput sgr0)"
      warnings+=('bare_slash')
      [[ -z "${fixed}" ]] && fixed="${homepage%/}/" || fixed="${fixed%/}/"
    fi
  fi

  if [[ "${#REVIEW_WARNINGS[@]}" -gt 0 ]]; then
    status_color=3
    status_msg='warning'
  fi

  warnings_str=$(join_by ', ' "${warnings[@]}")

  # check if output to CSV is needed
  if [[ "${#warnings[@]}" -gt 0 ]] || [[ "${SHOW_ALL}" == 'true' ]]; then
    # output to CSV
    show='true'
    output_csv "${cask}" "${homepage}" "${code}" "${status_msg}" "$([[ "${#warnings[@]}" -gt 0 ]] && echo "${warnings_str}" || echo '-')" "$([[ ! -z "${fixed}" ]] && echo "${fixed}" || echo '-')"
  fi

  # check if fixing is enabled and available
  if [[ "${FIX}" == 'true' ]] && [[ ! -z "${fixed}" ]]; then
    add_to_review 'Cask homepage' "${homepage} [$(tput setaf "${code_color}")${code}$(tput sgr0)] → $(tput setaf 7)${fixed}$(tput sgr0) [$(tput setaf 2)200$(tput sgr0)]"
    # fix
    FIXED_TOTAL+=1
    modify_stanza "${cask}" 'homepage' "'${fixed}'"
    git commit "${cask}.rb" --message "Update ${cask} homepage (${warnings_str})" --quiet
    status_color=2
    status_msg='fixed'
  else
    add_to_review 'Cask homepage' "${homepage} [$(tput setaf "${code_color}")${code}$(tput sgr0)]"
  fi

  if [[ "${skip}" == 'true' ]]; then
    status_color=7
    status_msg='skipped'
  fi

  add_to_review 'Status' "$(tput setaf "${status_color}")${status_msg}$(tput sgr0)"
}

# Finish the script.
#
# Stolen from https://github.com/vitorgalvao/tiny-scripts/blob/master/cask-repair.
#
# Globals:
#   BRANCH_NAME
#   REMOTE_PUSH
#
# Arguments:
#   $1 - Status: 'abort' or 'success'
#   $2 - Message
delete_created_branches() {
  local local_branches remote_branches

  # delete local branches
  local_branches=$(git branch --all | grep --extended-regexp "^ *${PROGRAM}_.*$" | perl -pe 's|^ *||;s|\n| |')
  [[ -n "${local_branches}" ]] && git branch -D ${local_branches}

  # delete remote branches
  git fetch --prune "${REMOTE_PUSH}"
  remote_branches=$(git branch --all | grep --extended-regexp "remotes/${REMOTE_PUSH}/${PROGRAM}_.*$" | perl -pe 's|.*/||;s|\n| |')
  [[ -n "${remote_branches}" ]] && git push "${REMOTE_PUSH}" --delete ${remote_branches}
}

# Prints rule with status.
#
# Arguments:
#   $1 - Rule
#   $2 - Description
print_rule() {
  local rule description enabled disabled

  readonly rule="$1"
  readonly description="$2"
  readonly enabled="$(tput setaf 2)enabled$(tput sgr0)"
  readonly disabled="$(tput setaf 1)disabled$(tput sgr0)"

  printf '%-12s %-21s %s\n' "${rule}" "$(check_rule_enabled "${rule}" && echo "${enabled}" || echo "${disabled}")" "${description}"
}

# Finish the script.
#
# Stolen from https://github.com/vitorgalvao/tiny-scripts/blob/master/cask-repair.
#
# Globals:
#   BRANCH_NAME
#
# Arguments:
#   $1 - Status: 'abort' or 'success'
#   $2 - Message
finish() {
  git reset HEAD --hard --quiet
  git checkout master --quiet
  [[ ! -z "${BRANCH_NAME}" ]] && git branch -D "${BRANCH_NAME}" --quiet

  # show message
  if [[ "$1" == 'abort' ]]; then
    echo -e "\n$(tput setaf 1)$2$(tput sgr0)"
    exit 1
  elif [[ "$1" == 'success' ]]; then
    echo -e "$(tput setaf 2)$2$(tput sgr0)"
    exit 0
  fi
}

# cleanup if aborted with ⌃C
trap 'finish abort "You aborted"' SIGINT

# Globals:
#   SHOW_ALL
#   REVIEW_NAMES
#   REVIEW_VALUES
#   CASKS
#   FIX
#   FIX_TOTAL
#
# Arguments:
#   $1 - Cask
main() {
  local cask show

  readonly cask="$1"
  show='false'

  add_to_review 'Cask name' "$(tput setaf 7)${cask}$(tput sgr0)"
  review_homepage "${cask}"
  [[ "${SHOW_ALL}" == 'true' ]] && show='true'
  [[ "${show}" == 'true' ]] && show_review 17

  # shellcheck disable=SC2034
  REVIEW_NAMES=()
  # shellcheck disable=SC2034
  REVIEW_VALUES=()

  [[ "${show}" == 'true' ]] && [[ "${#CASKS[@]}" -gt 1 ]] && divide
}

# delete branches
if [[ "${DELETE_CREATED_BRANCHES}" == 'true' ]]; then
  delete_created_branches
  exit 0
fi

# preparations
if [[ "${FIX}" == 'true' ]]; then
  [[ -z "${BRANCH_NAME}" ]] && BRANCH_NAME="${PROGRAM}_$(random 12)"
  git checkout master --quiet
  git pull --rebase "${REMOTE_PULL}" master --quiet
  git checkout -b "${BRANCH_NAME}" --quiet
fi

# process
[[ "${#CASKS[@]}" -eq 0 ]] && CASKS=($(egrep -lir --include '*.rb' "(homepage ')" . | xargs -n1 basename | sed 's|\.rb$||' | sort))
printf 'Checking homepages of %i ' "${#CASKS[@]}"
[[ "${#CASKS[@]}" -gt 1 ]] && printf 'casks' || printf 'cask'
printf ' using these rules:\n\n'
[[ "${OUTPUT}" == 'true' ]] && printf "\"%s\";\"%s\";\"%s\";\"%s\";\"%s\";\"%s\"\n" 'Name' 'Homepage' 'Response code' 'Status' 'Warnings' 'Fixed' > "${OUTPUT_PATH}"

for rule in "${RULES[@]}"; do
  rule=$(echo -n "${rule}" | xargs)
  check_array_contains 'RULES_DISABLED[@]' "${rule}" || RULES_ENABLED+=("${rule}")
done

print_rule 'bare_slash' 'Missing a bare domain URL trailing slash'
print_rule 'domain' 'Domain has changed'
print_rule 'http' 'Only HTTP is available'
print_rule 'https' 'HTTPS (for new domain) is available'
print_rule 'redirect' 'Redirect found'
print_rule 'slash' 'Server prefers to include a trailing slash'
print_rule 'no_slash' 'Server prefers to exclude a trailing slash'
print_rule 'www' 'Server prefers to include www'
print_rule 'no_www' 'Server prefers to exclude www'

if [[ "${#CASKS[@]}" -gt 1 ]] && [[ "${FIX}" == 'true' ]]; then
  [[ "${FIX_TOTAL}" -gt 0 ]] && printf "\nFixing first %i casks...\n" "${FIX_TOTAL}" || printf '\nFixing all casks...\n'
fi

divide

for cask in "${CASKS[@]}"; do
  [[ "${FIX_TOTAL}" -gt 0 ]] && [[ "${FIXED_TOTAL}" -eq "${FIX_TOTAL}" ]] && break
  main "${cask}"
done

# push
if [[ "${FIX}" == 'true' ]]; then
  git push --force "${REMOTE_PUSH}" "${BRANCH_NAME}" --quiet
  finish success "Pushed ${FIXED_TOTAL} casks in branch 'remotes/${REMOTE_PUSH}/${BRANCH_NAME}'..."
fi

exit 0
