#!/usr/bin/env bash
#
# Get the latest available version from appcast URL.
#
# Version:         0.3.5
# License:         The Unlicense (Public Domain)
# Author:          Victor Popkov <victor@popkov.me>
# Last modified:   31.05.2016

# Constants and globals
readonly VERSION='0.3.5'
readonly PROGRAM=$(basename "$0")
readonly BROWSER_HEADERS='User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/33.0.1750.152 Safari/537.36'
declare -a URLS
declare -a REVIEW
declare -i OPTIONS_COUNTER=0
GITHUB_USER=$(git config --get github.user)
GITHUB_TOKEN=$(git config --get github.token)
MATCHING_TAG=''
GITHUB_PRERELEASE='false'
DETAILED='true'
CHECKPOINT='false'
PROVIDER='false'
APP_VERSION='false'
DOWNLOADS='false'

# check if 'xmlstarlet' and 'jq' are installed and configured
if [[ ! $(which 'xmlstarlet') ]] || [[ ! $(which 'jq') ]]; then
  case "${OSTYPE}" in
    'darwin'*)
      echo -e "$(tput setaf 1)
        This script requires 'xmlstarlet' and 'jq' to be installed.
        If you have [Homebrew](http://brew.sh/), you can install both with 'brew install xmlstarlet jq'.
      $(tput sgr0)" | sed -E 's/ {8}//' >&2
      ;;
    'linux-gnu')
      echo -e "$(tput setaf 1)
        This script requires 'xmlstarlet' and 'jq' to be installed.
        You can install both with 'apt-get install xmlstarlet jq'.
      $(tput sgr0)" | sed -E 's/ {8}//' >&2
      ;;
    *)
      echo -e "$(tput setaf 1)
        This script requires 'xmlstarlet' and 'jq' to be installed.
      $(tput sgr0)" | sed -E 's/ {8}//' >&2
      ;;
  esac
  exit 1
fi

# Display syntax error.
#
# Globals:
#   PROGRAM
#
# Arguments:
#   $1 - Error description
#
# Returns exit status 1.
syntax_error() {
  echo "${PROGRAM}: $1" >&2
  echo "Try \`${PROGRAM} --help\` for more information." >&2
  exit 1
}

# Display error.
#
# Arguments:
#   $1 - Error description
#
# Returns exit status 1.
error() {
  echo -e "$(tput setaf 1)$1$(tput sgr0)"
  exit 1
}

# Display help.
#
# Globals:
#   PROGRAM
usage() {
  echo "usage: ${PROGRAM} [options] [<appcast_urls>...]

    Get the latest available version from appcast URL. Currently supports only Sparkle and GitHub Atom.

    options:
      -u <user>, --github-user <user>      GitHub username (default: 'git config --get github.user').
      -t <token>, --github-token <token>   GitHub personal token (default: 'git config --get github.token').
      -s <mode>, --stability <mode>        Try to get 'stable' or 'unstable' latest version if possible (default: 'stable').
      -m <tag>, --match <tag>              Try to filter using matching tag.
      -c, --checkpoint                     Output checkpoint.
      -p, --provider                       Output provider (Sparkle or GitHub Atom).
      -V, --app-version                    Output app version and build (if available).
      -d, --downloads                      Output downloads.
      -v, --version                        Show current script version.
      -h, --help                           Show this help." | sed -E 's/^ {4}//'
}

# exit if no argument or more than one argument was given
if [[ "${#}" -eq 0 ]]; then
  usage
  exit 1
fi

# available flags
while [[ "$1" ]]; do
  case "$1" in
    -u | --github-user)
      readonly GITHUB_USER="$2"
      shift
      ;;
    -t | --github-token)
      readonly GITHUB_TOKEN="$2"
      shift
      ;;
    -s | --stability)
      case "$2" in
        stable)   GITHUB_PRERELEASE='false' ;;
        unstable) GITHUB_PRERELEASE='true' ;;
        *) error "The '--stability' should have one of the values: 'stable' or 'unstable'" ;;
      esac
      shift
      ;;
    -m | --match)
      readonly MATCHING_TAG="$2"
      shift
      ;;
    -c | --checkpoint)
      ((OPTIONS_COUNTER++))
      CHECKPOINT='true'
      DETAILED='false'
      ;;
    -p | --provider)
      ((OPTIONS_COUNTER++))
      PROVIDER='true'
      DETAILED='false'
      ;;
    -V | --app-version)
      ((OPTIONS_COUNTER++))
      APP_VERSION='true'
      DETAILED='false'
      ;;
    -d | --downloads)
      ((OPTIONS_COUNTER++))
      DOWNLOADS='true'
      DETAILED='false'
      ;;
    -v | --version)
      echo "${VERSION}"
      exit 0
      ;;
    -h | --help)
      usage
      exit 0
      ;;
    -*)
      syntax_error "unrecognized option: $1"
      ;;
    *)
      URLS=("$@")
      for url in "${URLS[@]}"; do
        if [[ ! "${url}" =~ (https?|ftp|file)://[-A-Za-z0-9\+\&@#/%?=~_|!:,.\;]*[-A-Za-z0-9\+\&@#/%=~_|] ]]; then
          if [[ "${#URLS[@]}" -gt 1 ]]; then error 'One of the provided appcast URLs is not valid'
          else error 'The provided appcast URL is not valid'; fi
        fi
      done
      break
      ;;
  esac
  shift
done

# exit if no URLs provided
[[ "${#URLS[@]}" -eq 0 ]] && error 'The appcast URL not provided'

# Divider to separate output in terminal.
#
# Globals:
#   COLUMNS
divide() {
  if [[ $(which hr) ]]; then hr '-'
  else printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -; fi
}

# Extract version from string.
#
# Arguments:
#   $1 - Version
#
# Returns version.
extract_version() {
  sed -e 's/[^0-9.]*\([0-9A-Za-z.]*\).*/\1/' <<< "$1"
}

# Version comparison.
#
# Use 'sort -V' if available, otherwise use custom solution.
#
# Arguments:
#   $1 - First version
#   $2 - Second version
#
# Returns:
#   0 - First = second
#   1 - First > second
#   2 - First < second
compare_versions() {
  local first second

  first=$(extract_version "$1")
  second=$(extract_version "$2")

  [[ "${first}" == "${second}" ]] && return 0

  if echo | sort -Vr > /dev/null 2>&1; then
    local versions
    readonly versions=($(printf '%s\n%s\n' "${first}}" "${second}" | sort -Vr))
    [[ "${first}" == "${versions[0]}" ]] && return 1
    [[ "${second}" == "${versions[0]}" ]] && return 2
  else
    # inspired by: http://stackoverflow.com/a/4025065
    local IFS='.'
    local i
    first=($(sed -e 's/[A-Za-z]/ /g' <<< "${first}" | tr -s ' ' '.'))
    second=($(sed -e 's/[A-Za-z]/ /g' <<< "${second}" | tr -s ' ' '.'))
    for ((i = ${#first[@]}; i < ${#second[@]}; i++)); do first[i]=0; done
    for ((i = 0; i < ${#first[@]}; i++)); do
      [[ -z "${second[i]}" ]] && second[i]=0
      ((10#${first[i]} > 10#${second[i]})) && return 1
      ((10#${first[i]} < 10#${second[i]})) && return 2
    done
  fi

  return 0
}

# Create sha256 checksum from that represents appcast checkpoint from piped content string.
#
# Arguments:
#   $1 - Content
#
# Returns checkpoint.
generate_appcast_checkpoint() {
  sed -e 's/<pubDate>[^<]*<\/pubDate>//g' <<< "$1" | shasum --algorithm 256 | awk '{ print $1 }'
}

# Get content from URL.
#
# Globals:
#   BROWSER_HEADERS
#
# Arguments:
#   $1 - URL
#
# Returns content and status code (last line).
get_url_content() {
  curl --silent --compressed --location "$1" --header "${BROWSER_HEADERS}" --max-time 10 --write-out '\n%{http_code}' 2>/dev/null
}

# Format XML content using xmlstarlet and uncomment tags.
#
# Arguments:
#   $1 - Content
#
# Returns formatted XML and return status.
format_xml() {
  local content

  content="$1"
  [[ -z "${content}" ]] && return 1

  content=$(xmlstarlet fo -s 4 -o -D -N <<< "${content}" 2> /dev/null)
  content=$(awk '{ sub(/<!--([[:space:]]*)?</, "<"); sub(/>([[:space:]]*)?-->/, ">"); print }' <<< "${content}") # uncomment tags

  echo "${content}"
  return 0
}

# Make Sparkle namespaces more consistent.
#
# Arguments:
#   $1 - Content
#
# Returns XML with fixed namespaces and status.
fix_sparkle_xmlns() {
  local content

  readonly content="$1"
  [[ -z "${content}" ]] && return 1

  if [[ "${content}" =~ '<rss'.*'xmlns:sparkle' ]]; then
    sed -e 's/ xmlns:sparkle=".*"/ xmlns:sparkle="http:\/\/www.andymatuschak.org\/xml-namespaces\/sparkle"/g' <<< "${content}"
  else
    sed -e 's/<rss/<rss xmlns:sparkle="http:\/\/www.andymatuschak.org\/xml-namespaces\/sparkle"/g' <<< "${content}"
  fi

  return 0
}

# Transform Sparkle line to array of values.
#
# Arguments:
#   $1 - Line in format: "<version>";"<build>";"<url>";"<title>"
#
# Returns array of values:
#   <version>
#   <build>
#   <url>
get_sparkle_version_build_url() {
  local version version_before build url title
  local -a vars

  IFS=';' read -ra vars <<< "$1"

  version="${vars[0]//[\"[:space:]]}"
  readonly version_before="${version}"
  readonly build="${vars[1]//[\"[:space:]]}"
  readonly url=$(echo "${vars[2]}" | sed -e 's/"//g' | sed -e 's/["[:space:]]/%20/g')
  readonly title="${vars[3]//[\"]}"

  [[ -z "${version}" ]] && [[ ! -z "${build}" ]] && version="${build}"
  [[ -z "${version}" ]] && [[ -z "${build}" ]] && version=$(extract_version "${title}")
  readonly version

  result=("${version}" "${build}" "${url}")
  if [[ "${version}" == "${build}" ]] || [[ -z "${version_before}" ]]; then result=("${version}" "${url}"); fi

  echo "${result[@]}"
}

# Get latest version values from content of Sparkle appcast.
#
# Arguments:
#   $1 - Content
#
# Returns status and array of values of latest version:
#   <version>
#   <build>
#   <url>
get_sparkle_latest() {
  local IFS content transform
  local -a lines first last values result

  content=$(fix_sparkle_xmlns "$1")
  content=$(format_xml "${content}")
  readonly content

  readonly transform=$(xmlstarlet sel -t -m '//channel/item' \
-o '"' -i 'sparkle:shortVersionString' -v 'sparkle:shortVersionString' --else -v 'enclosure/@sparkle:shortVersionString' -b -o '";' \
-o '"' -i 'sparkle:version' -v 'sparkle:version' --else -v 'enclosure/@sparkle:version' -b -o '";' \
-o '"' -i 'link' -v 'link' --else -v 'enclosure/@url' -b -o '";' \
-o '"' -v 'title' -o '";' -n <<< "${content}" 2> /dev/null)

  IFS=$'\n' read -rd '' -a lines <<< "${transform}"
  [[ "${#lines[@]}" -eq 0 ]] && return 1

  readonly first=($(get_sparkle_version_build_url "${lines[0]}"))

  if [[ "${#lines[@]}" -gt 1 ]]; then
    readonly last=($(get_sparkle_version_build_url "${lines[${#lines[@]}-1]}"))

    compare_versions "${first[0]}" "${last[0]}"
    case $? in
      0) values=("${first[@]}") ;; # =
      1) values=("${first[@]}") ;; # >
      2) values=("${last[@]}") ;;  # <
    esac
  else
    values=("${first[@]}")
  fi
  readonly values

  echo "${values[@]}"
  return 0
}

# Parse content of GitHub Atom appcast to extract all values.
#
# Globals:
#   GITHUB_USER
#   GITHUB_TOKEN
#   BROWSER_HEADERS
#   GITHUB_PRERELEASE
#
# Arguments:
#   $1 - URL
#   $2 - Match tag
#
# Returns array of values:
#   <prerelease>      (true|false)
#   <version>
#   <download_urls>   (array)
parse_appcast_github_latest() {
  local auth user repo match url out code content latest_tag prerelease_tag version prerelease download_urls
  local -a result

  [[ ! -z "${GITHUB_USER}" ]] && [[ ! -z "${GITHUB_TOKEN}" ]] && auth=(--user "${GITHUB_USER}:${GITHUB_TOKEN}")

  IFS='/' read -ra parts <<< "$1"
  readonly parts
  readonly user="${parts[3]}"
  readonly repo="${parts[4]}"
  readonly match="$2"

  readonly url="https://api.github.com/repos/${user}/${repo}/releases"
  readonly out=$(curl --silent --compressed --location "${url}" "${auth[@]}" --header "${BROWSER_HEADERS}" --max-time 10 --write-out '\n%{http_code}' 2>/dev/null)
  readonly code=$(echo "${out}" | tail -n1)
  readonly content=$(echo "${out}" | sed \$d)

  [[ "${code}" -eq 403 ]] && return 2

  if [[ ! -z "${match}" ]]; then
    latest_tag=$(echo "${content}" | jq ".|=sort_by(.created_at) | reverse | .[] | select(.prerelease == false) | .tag_name" 2> /dev/null | grep -i "${match}" | head -1 | xargs)
    prerelease_tag=$(echo "${content}" | jq ".|=sort_by(.created_at) | reverse | .[] | select(.prerelease == true) | .tag_name" 2> /dev/null | grep -i "${match}" | head -1 | xargs)
  fi

  if [[ -z "${latest_tag}" ]] && [[ -z "${prerelease_tag}" ]]; then
    latest_tag=$(echo "${content}" | jq ".|=sort_by(.created_at) | reverse | .[] | select(.prerelease == false) | .tag_name" 2> /dev/null | head -1 | xargs)
    prerelease_tag=$(echo "${content}" | jq ".|=sort_by(.created_at) | reverse | .[] | select(.prerelease == true) | .tag_name" 2> /dev/null | head -1 | xargs)
  fi

  readonly latest_tag prerelease_tag

  version="${latest_tag}"
  compare_versions "${latest_tag}" "${prerelease_tag}"
  [[ "$?" -eq 2 ]] && [[ "${GITHUB_PRERELEASE}" == 'true' ]] && version="${prerelease_tag}" # if latest_tag < prerelease_tag

  [[ -z "${version}" ]] && return 1

  prerelease='false'
  [[ "${version}" == "${prerelease_tag}" ]] && prerelease='true'

  readonly download_urls=($(echo "${content}" | jq ".[] | select(.tag_name == \"${version}\") | .assets" | jq '.[] | .browser_download_url' 2> /dev/null | xargs))
  version=$(grep -q 'v[0-9]' <<< "${version}" && echo "${version/v}" || echo "${version}") # v3.0 => 3.0
  result+=("${prerelease}")
  result+=("${version}")
  result+=("${download_urls[@]}")

  echo "${result[@]}"
}

# Guess the appcast provider from the content.
#
# Arguments:
#   $1 - Content
#
# Returns provider and status.
get_appcast_provider() {
  local content result

  readonly content="$1"

  # GitHub
  [[ "${content}" =~ '<feed'.*'<id>tag:github.com' ]] && result='GitHub Atom'

  # RSS
  if [[ "${content}" =~ '<rss'.* ]]; then
    # Sparkle
    [[ "${content}" =~ '<rss'.*'xmlns:sparkle' ]] && result='Sparkle'
    [[ "${content}" =~ '<item'.*'<enclosure' ]] && result='Sparkle'
  fi
  readonly result

  if [[ ! -z "${result}" ]]; then
    echo "${result}"
    return 0
  fi

  return 1
}

# Extract version number from URL or content.
#
# Globals:
#   MATCHING_TAG
#
# Arguments:
#   $1 - URL     (required)
#   $2 - Content (not required)
#
# Returns version.
get_appcast_version() {
  local url content out code values version

  readonly url="$1"

  content="$2"
  if [[ -z "$2" ]]; then
    readonly out=$(get_url_content "${url}")
    readonly code=$(echo "${out}" | tail -n1)
    content=$(echo "${out}" | sed \$d)
  fi
  readonly content

  case "$(get_appcast_provider "${content}")" in
    'Sparkle')
      readonly values=($(get_sparkle_latest "${content}"))
      version="${values[0]}"
      [[ "${#values[@]}" -eq 3 ]] && [[ "${values[0]}" != "${values[1]}" ]] && version="${values[0]},${values[1]}"
      [[ ! -z "${version}" ]] && echo "${version}" && return 0
    ;;
    'GitHub Atom')
      readonly values=($(get_sparkle_latest "${url}" "${MATCHING_TAG}"))
      [[ ! -z "${values[1]}" ]] && echo "${values[1]}" && return 0
    ;;
  esac

  return 1
}

# Extract download URLs from appcast URL or content.
#
# Globals:
#   MATCHING_TAG
#
# Arguments:
#   $1 - URL     (required)
#   $2 - Content (not required)
#
# Returns array of dowload URLs.
get_appcast_downloads() {
  local url content out code values download_url
  local -a output

  readonly url="$1"

  content="$2"
  if [[ -z "$2" ]]; then
    readonly out=$(get_url_content "${url}")
    readonly code=$(echo "${out}" | tail -n1)
    content=$(echo "${out}" | sed \$d)
  fi
  readonly content

  case "$(get_appcast_provider "${content}")" in
    'Sparkle')
      readonly values=($(get_sparkle_latest "${content}"))
      download_url="${values[1]}"
      [[ "${#values[@]}" -eq 3 ]] && download_url="${values[2]}"
      [[ ! -z "${download_url}" ]] && echo "${download_url}" && return 0
    ;;
    'GitHub Atom')
      readonly values=($(get_sparkle_latest "${url}" "${MATCHING_TAG}"))
      if [[ "${#values[@]}" -gt 1 ]]; then
        for ((i = 2; i < ${#values[@]}; i++)); do
          output+=(${values[i]})
        done
        echo "${output[@]}" && return 0
      fi
    ;;
  esac

  return 1
}

# Add info to review.
#
# Globals:
#   REVIEW
#
# Arguments:
#   $1 - Name
#   $2 - Value
add_to_review() {
  local name
  [[ ! -z "$1" ]] && name="$1:" || name="$1"
  REVIEW+=("$(printf "%-21s %s" "${name}" "$2")")
}

# Show review.
#
# Globals:
#   REVIEW
show_review() {
  [[ "${#REVIEW[@]}" -gt 0 ]] && printf '%s\n' "${REVIEW[@]}"
}

# Create review for Sparkle appcast.
#
# Arguments:
#   $1 - Content
review_sparkle() {
  local values version build download_url

  add_to_review 'Provider' 'Sparkle'
  readonly values=($(get_sparkle_latest "$1"))
  if [[ "$?" -gt 0 ]]; then
    add_to_review '' "$(tput setaf 3)no results available$(tput sgr0)"
  else
    version="${values[0]}"
    build="${values[1]}"
    download_url="${values[1]}"
    [[ "${#values[@]}" -eq 3 ]] && download_url="${values[2]}"

    # version
    [[ -z "${version}" ]] && version='-'
    add_to_review 'Latest version' "${version}"

    # build
    [[ "${#values[@]}" -eq 3 ]] && [[ "${version}" != "${build}" ]] && add_to_review 'Latest build' "${build}"

    # download url
    [[ -z "${download_url}" ]] && download_url='-'
    add_to_review 'Latest download URL' "${download_url}"
  fi
}

# Create review for GitHub Atom appcast.
#
# Globals:
#   MATCHING_TAG
#
# Arguments:
#   $1 - URL
review_github() {
  local url stat_name_downloads values version
  local -i status

  add_to_review 'Provider' 'GitHub Atom'

  readonly url="$1"
  readonly values=($(parse_appcast_github_latest "${url}" "${MATCHING_TAG}"))
  readonly status="$?"

  if [[ "${status}" -gt 0 ]]; then
    case "${status}" in
      2) add_to_review '' "$(tput setaf 1)API rate limit exceeded$(tput sgr0)";;
      *) add_to_review '' "$(tput setaf 3)no results available$(tput sgr0)";;
    esac
  else
    [[ "${values[0]}" == 'true' ]] && label="$(tput setaf 3)Pre-release$(tput sgr0)" || label="$(tput setaf 2)Latest$(tput sgr0)"
    [[ ! -z "${values[1]}" ]] && version="$(printf "%s (%s)" "${values[1]}" "${label}")" || version='-'

    add_to_review 'Latest version' "${version}"

    stat_name_downloads='Latest download URL'
    if [[ "${#values[@]}" -gt 2 ]]; then
      [[ "${#values[@]}" -gt 3 ]] && stat_name_downloads+='s'
      add_to_review "${stat_name_downloads}" "${values[2]}"
      for ((i = 3; i < ${#values[@]}; i++)); do
        add_to_review '' "${values[i]}"
      done
    else
      add_to_review "${stat_name_downloads}" '-'
    fi
  fi
}

# Globals:
#   URLS
#   CHECKPOINT
#   PROVIDER
#   APP_VERSION
#   DOWNLOADS
#   OPTIONS_COUNTER
#   DETAILED
#   REVIEW
#
# Arguments:
#   $1 - URL
main() {
  local url out content code result status

  readonly url="$1"
  readonly out=$(get_url_content "${url}")
  readonly content=$(echo "${out}" | sed \$d)
  readonly code=$(echo "${out}" | tail -n1)

  if [[ "${CHECKPOINT}" == 'true' ]]; then
    result=$(generate_appcast_checkpoint "${content}")
    [[ "$?" -eq 0 ]] && printf "%s" "${result}" || printf '-'
    [[ "${OPTIONS_COUNTER}" -gt 1 ]] && printf ';'
  fi

  if [[ "${PROVIDER}" == 'true' ]]; then
    result=$(get_appcast_provider "${content}")
    [[ "$?" -eq 0 ]] && printf "%s" "${result}" || printf '-'
    [[ "${OPTIONS_COUNTER}" -gt 1 ]] && printf ';'
  fi

  if [[ "${APP_VERSION}" == 'true' ]]; then
    result=$(get_appcast_version "${url}" "${content}")
    [[ "$?" -eq 0 ]] && printf "%s" "${result}" || printf '-'
    [[ "${OPTIONS_COUNTER}" -gt 1 ]] && printf ';'
  fi

  if [[ "${DOWNLOADS}" == 'true' ]]; then
    result=$(get_appcast_downloads "${url}" "${content}")
    [[ "$?" -eq 0 ]] && printf "%s" "${result}" || printf '-'
    [[ "${OPTIONS_COUNTER}" -gt 1 ]] && printf ';'
  fi

  [[ "${code}" -eq 200 ]] && status="$(tput setaf 2)${code}$(tput sgr0)" || status="$(tput setaf 1)${code}$(tput sgr0)"

  if [[ "${DETAILED}" == 'true' ]]; then
    add_to_review 'Appcast' "$(tput setaf 7)${url}$(tput sgr0) (${status})"

    if [[ "${code}" -ne 200 ]]; then
      add_to_review 'Status' "$(tput setaf 1)HTTP Error ${code}$(tput sgr0)"
    else
      add_to_review 'Checkpoint' "$(generate_appcast_checkpoint "${content}")"

      case "$(get_appcast_provider "${content}")" in
        'Sparkle')     review_sparkle "${content}";;
        'GitHub Atom') review_github "${url}";;
        *) add_to_review 'Provider' "$(tput setaf 3)unknown$(tput sgr0)";;
      esac
    fi

    show_review
    [[ "${#URLS[@]}" -gt 1 ]] && [[ "${URLS[${#URLS[@]}-1]}" != "${url}" ]] && divide
    REVIEW=()
  else
    printf "\n"
  fi

  [[ "${code}" -eq 200 ]] && return 0 || return 1
}

# process
[[ "${DETAILED}" == 'true' ]] && [[ "${#URLS[@]}" -gt 1 ]] && printf "Checking %s appcasts...\n" "${#URLS[@]}" && divide
for url in "${URLS[@]}"; do main "${url}"; done

exit 0
