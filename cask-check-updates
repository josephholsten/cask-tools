#!/usr/bin/env bash
#
# Find outdated casks and their latest versions.
#
# Version:         0.4.4
# License:         The Unlicense (Public Domain)
# Author:          Victor Popkov <victor@popkov.me>
# Last modified:   31.05.2016

# Constants and globals
readonly VERSION='0.4.4'
readonly PROGRAM=$(basename "$0")
readonly TEMP_DIR=$(mktemp -d)
readonly BROWSER_HEADERS='User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/33.0.1750.152 Safari/537.36'
declare -a CASKS
declare -a REVIEW
declare -a CASKS_VERSION_DELIMETER_BUILD
GITHUB_USER=$(git config --get github.user)
GITHUB_TOKEN=$(git config --get github.token)
GITHUB_PRERELEASE='false'
OUTPUT='false'
OUTPUT_PATH=''
SHOW_ALL='false'
SHOW_CHECKPOINTS='false'

# Casks which versions should have format: "<version><delimeter><build>"
declare -a -r CASKS_VERSION_DELIMETER_BUILD=(
  'airmail-beta'
  'aliwangwang'
  'alternote'
  'appfresh'
  'appfresh'
  'beatport-pro'
  'cartographica'
  'codekit'
  'dradio'
  'dterm'
  'evernote'
  'findings'
  'flexiglass'
  'gog-downloader'
  'graphicconverter'
  'hipchat'
  'hype'
  'intensify-pro'
  'invisionsync'
  'jollysfastvnc'
  'kaleidoscope'
  'kamakiri'
  'kiwi'
  'lytro-desktop'
  'mplayerx'
  'netnewswire'
  'otomatic'
  'papers'
  'phoneexpander'
  'pixlr'
  'simple-hub'
  'sketch-beta'
  'soulver'
  'splice'
  'stand'
  'stretchlink'
  'the-hit-list'
  'tripmode'
  'tvshows'
  'versions'
)

# Casks which appcasts contain multiple apps/tags
declare -a -r CASKS_MATCHING_TAG=(
  'adobe-bloodhound' 'Bloodhound'
)

# check if 'xmlstarlet' and 'jq' are installed and configured
if [[ ! $(which 'xmlstarlet') ]] || [[ ! $(which 'jq') ]]; then
  case "${OSTYPE}" in
    'darwin'*)
      echo -e "$(tput setaf 1)
        This script requires 'xmlstarlet' and 'jq' to be installed.
        If you have [Homebrew](http://brew.sh/), you can install both with 'brew install xmlstarlet jq'.
      $(tput sgr0)" | sed -E 's/ {8}//' >&2
      ;;
    'linux-gnu')
      echo -e "$(tput setaf 1)
        This script requires 'xmlstarlet' and 'jq' to be installed.
        You can install both with 'apt-get install xmlstarlet jq'.
      $(tput sgr0)" | sed -E 's/ {8}//' >&2
      ;;
    *)
      echo -e "$(tput setaf 1)
        This script requires 'xmlstarlet' and 'jq' to be installed.
      $(tput sgr0)" | sed -E 's/ {8}//' >&2
      ;;
  esac
  exit 1
fi

# Display syntax error.
#
# Globals:
#   PROGRAM
#
# Arguments:
#   $1 - Error description
#
# Returns exit status 1.
syntax_error() {
  echo "${PROGRAM}: $1" >&2
  echo "Try \`${PROGRAM} --help\` for more information." >&2
  exit 1
}

# Display error.
#
# Arguments:
#   $1 - Error description
#
# Returns exit status 1.
error() {
  echo "$(tput setaf 1)$1$(tput sgr0)" >&2
  exit 1
}

# Display help.
#
# Globals:
#   PROGRAM
usage() {
  echo "usage: ${PROGRAM} [options]

    Find outdated casks and their latest versions.

    options:
      -u <user>, --github-user <user>      GitHub username (default: 'git config --get github.user').
      -t <token>, --github-token <token>   GitHub personal token (default: 'git config --get github.token').
      -o <filepath>, --output <filepath>   Output the results into file using CSV format.
      -s <mode>, --stability <mode>        Try to get 'stable' or 'unstable' latest version if possible (default: 'stable').
      -a, --all                            Show and output also all updated casks.
      -c, --checkpoints                    Include checkpoints validations.
      -v, --version                        Show current script version.
      -h, --help                           Show this help." | sed -E 's/^ {4}//'
}

# Divider to separate output in terminal.
#
# Globals:
#   COLUMNS
divide() {
  if [[ $(which hr) ]]; then hr '-'
  else printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -; fi
}

# available flags
while [[ "$1" ]]; do
  case "$1" in
    -a | --all)
      SHOW_ALL='true'
      ;;
    -c | --checkpoints)
      readonly SHOW_CHECKPOINTS='true'
      ;;
    -u | --github-user)
      readonly GITHUB_USER="$2"
      shift
      ;;
    -t | --github-token)
      readonly GITHUB_TOKEN="$2"
      shift
      ;;
    -o | --output)
      readonly OUTPUT='true'
      readonly OUTPUT_PATH="$2"
      shift
      ;;
    -s | --stability)
      case "$2" in
        stable)   GITHUB_PRERELEASE='false' ;;
        unstable) GITHUB_PRERELEASE='true' ;;
        *) error "The '--stability' should have one of the values: 'stable' or 'unstable'" ;;
      esac
      shift
      ;;
    -v | --version)
      echo "${VERSION}"
      exit 0
      ;;
    -h | --help)
      usage
      exit 0
      ;;
    -*)
      syntax_error "unrecognized option: $1"
      ;;
    *)
      for arg in "$@"; do
        cask="${arg/.rb}"
        [[ -f "${cask}.rb" ]] && CASKS+=("${cask}") || printf "Cask '%s' not found\n" "${cask}"
      done
      [[ "$#" != "${#CASKS[@]}" ]] && [[ "${#CASKS[@]}" -eq 0 ]] && exit 1

      readonly SHOW_ALL='true'
      break
      ;;
  esac
  shift
done

# check if in correct directory
if ! pwd | grep -q 'homebrew-.*/Casks'; then
  error "You need to be inside a '/homebrew-*/Casks' directory"
fi

# Unquote a piped string and remove a trailing comma.
#
# Returns unquoted string.
unquote() {
  while read -r data; do
    sed -e 's/,$//' -e "s/^\([\"']\)\(.*\)\1\$/\2/g" <<< "${data}"
  done
}

# Get value/values of a cask stanza.
#
# Arguments:
#   $1 - Cask name   (required)
#   $2 - Stanza name (required)
#   $3 - Content     (not required)
#
# Returns the stanza value.
get_cask_stanza_value() {
  local cask stanza content

  readonly cask="$1"
  readonly stanza="$2"

  content="$3"
  [[ -z "$3" ]] && content=$(cat "${cask}.rb")
  readonly content

  grep "${stanza} " <<< "${content}" | sed -e "s/${stanza} //g" -e 's/ //g' | awk '{ print $1 }' | sed -e 's/,$//' -e 's/^.//' -e 's/.$//'
}

# Get appcast, checkpoint and url for each version of the cask.
#
# Arguments:
#   $1 - Cask name
#
# Returns values of each version line by line format:
#   "<version>" "<appcast>" "<checkpoint>" "<url>"
get_cask_version_appcast_checkpoint_url() {
  local caskname cask next content appcast checkpoint
  local -a versions urls appcasts checkpoints line

  readonly caskname="$1"
  readonly cask="${caskname}.rb"
  readonly versions=($(grep "^\s*.version " < "${cask}" | awk '{ print $2 }' | unquote))
  readonly appcasts=($(grep "^\s*.appcast " < "${cask}" | awk '{ print $2 }' | unquote))
  readonly checkpoints=($(grep "^\s*.checkpoint: " < "${cask}" | awk '{ print $2 }' | unquote))
  readonly urls=($(grep "^\s*.url " < "${cask}" | awk '{ print $2 }' | unquote))

  for ((i = 0; i < ${#versions[@]}; i++)); do
    line=()

    [[ "$((i+1))" -lt "${#versions[@]}" ]] && next="/version '${versions[$i+1]}'/" || next='0'
    content=$(awk "/version '${versions[i]}'/,${next}" < "${cask}")

    appcast=$(get_cask_stanza_value "${caskname}" 'appcast' "${content}")
    checkpoint=$(get_cask_stanza_value "${caskname}" 'checkpoint:' "${content}")
    if [[ "${#versions[@]}" -gt "${#urls[@]}" ]] || [[ "${#versions[@]}" -eq "${#urls[@]}" ]]; then
      [[ "${#urls[@]}" -gt 1 ]] && url=$(get_cask_stanza_value "${caskname}" 'url' "${content}") || url="${urls[0]}"
    else
      url="${urls[${#urls[@]}-1]}"
    fi

    line+=("\"${versions[i]}\"")
    line+=("\"${appcast}\"")
    line+=("\"${checkpoint}\"")
    line+=("\"${url}\"")

    echo "${line[@]}"
  done
}

# Extract version from string.
#
# Arguments:
#   $1 - Version
#
# Returns version.
extract_version() {
  sed -e 's/[^0-9.]*\([0-9A-Za-z.]*\).*/\1/' <<< "$1"
}

# Version comparison.
#
# Use 'sort -V' if available, otherwise use custom solution.
#
# Arguments:
#   $1 - First version
#   $2 - Second version
#
# Returns:
#   0 - First = second
#   1 - First > second
#   2 - First < second
compare_versions() {
  local first second

  first=$(extract_version "$1")
  second=$(extract_version "$2")

  [[ "${first}" == "${second}" ]] && return 0

  if echo | sort -Vr > /dev/null 2>&1; then
    local versions
    readonly versions=($(printf '%s\n%s\n' "${first}}" "${second}" | sort -Vr))
    [[ "${first}" == "${versions[0]}" ]] && return 1
    [[ "${second}" == "${versions[0]}" ]] && return 2
  else
    # inspired by: http://stackoverflow.com/a/4025065
    local IFS='.'
    local i
    first=($(sed -e 's/[A-Za-z]/ /g' <<< "${first}" | tr -s ' ' '.'))
    second=($(sed -e 's/[A-Za-z]/ /g' <<< "${second}" | tr -s ' ' '.'))
    for ((i = ${#first[@]}; i < ${#second[@]}; i++)); do first[i]=0; done
    for ((i = 0; i < ${#first[@]}; i++)); do
      [[ -z "${second[i]}" ]] && second[i]=0
      ((10#${first[i]} > 10#${second[i]})) && return 1
      ((10#${first[i]} < 10#${second[i]})) && return 2
    done
  fi

  return 0
}

# Create sha256 checksum from content that represents appcast checkpoint.
#
# Arguments:
#   $1 - Content to generate checkpoint from
#
# Returns checkpoint.
generate_appcast_checkpoint() {
  echo "$1" | sed 's|<pubDate>[^<]*</pubDate>||g' | shasum --algorithm 256 | awk '{ print $1 }' && return 0 || return 1
}

# Get content from URL.
#
# Globals:
#   BROWSER_HEADERS
#
# Arguments:
#   $1 - URL
#
# Returns content and status code (last line).
get_url_content() {
  curl --silent --compressed --location "$1" --header "${BROWSER_HEADERS}" --max-time 10 --write-out '\n%{http_code}' 2>/dev/null
}

# Process parsed Sparkle line to get variables.
#
# Arguments:
#   $1 - Line in format: "<version>";"<build>";"<url>";"<title>"
#
# Returns array of values:
#   <version>
#   <build>
#   <url>
process_appcast_sparkle_line() {
  local version version_before build url title
  local -a vars

  IFS=';' read -ra vars <<< "$1"

  version="${vars[0]//[\"[:space:]]}"
  readonly version_before="${version}"
  readonly build="${vars[1]//[\"[:space:]]}"
  readonly url=$(echo "${vars[2]}" | sed -e 's/"//g' | sed -e 's/["[:space:]]/%20/g')
  readonly title="${vars[3]//[\"]}"

  [[ -z "${version}" ]] && [[ ! -z "${build}" ]] && version="${build}"
  [[ -z "${version}" ]] && [[ -z "${build}" ]] && version=$(extract_version "${title}")
  readonly version

  result=("${version}" "${build}" "${url}")
  if [[ "${version}" == "${build}" ]] || [[ -z "${version_before}" ]]; then result=("${version}" "${url}"); fi

  echo "${result[@]}" && return 0
}

# Parse content of Sparkle appcast to extract all values.
#
# Globals:
#   PROGRAM
#
# Arguments:
#   $1 - Content to parse
#
# Returns array of values:
#   <version>
#   <build>
#   <url>
parse_appcast_sparkle_latest() {
  local content xls transform
  local -a lines first last values result

  content=$(sed -e $'s/></>\\\n</g' <<< "${1}") # convert single line XML to multiline

  # make sparkle namespace more consistent and ignore others
  if [[ "${content}" =~ '<rss'.*'xmlns:sparkle' ]]; then
    content=$(sed -e 's/ xmlns:sparkle=".*"/ xmlns:sparkle="http:\/\/www.andymatuschak.org\/xml-namespaces\/sparkle"/g' <<< "${content}")
  else
    content=$(sed -e 's/<rss/<rss xmlns:sparkle="http:\/\/www.andymatuschak.org\/xml-namespaces\/sparkle"/g' <<< "${content}")
  fi

  readonly content=$(sed -e 's/<!--</</g' -e 's/\/>-->/\/>/g' <<< "${content}") # uncomment tags

  xls=$(cat <<EOF
<?xml version="1.0"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:sparkle="http://www.andymatuschak.org/xml-namespaces/sparkle">
    <xsl:output method="text" omit-xml-declaration="yes" indent="no" />
    <xsl:strip-space elements="*" />
    <xsl:template match="//channel">
        <xsl:for-each select="item">
            <xsl:choose>
                <xsl:when test="enclosure/@sparkle:shortVersionString or sparkle:shortVersionString">
                    <xsl:choose>
                        <xsl:when test="enclosure/@sparkle:shortVersionString">
                            <xsl:text>"</xsl:text>
                            <xsl:value-of select="enclosure/@sparkle:shortVersionString" />
                            <xsl:text>";</xsl:text>
                        </xsl:when>
                        <xsl:when test="sparkle:shortVersionString">
                            <xsl:text>"</xsl:text>
                            <xsl:value-of select="sparkle:shortVersionString" />
                            <xsl:text>";</xsl:text>
                        </xsl:when>
                    </xsl:choose>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:text>"";</xsl:text>
                </xsl:otherwise>
            </xsl:choose>
            <xsl:choose>
                <xsl:when test="enclosure/@sparkle:version or sparkle:version">
                    <xsl:choose>
                        <xsl:when test="enclosure/@sparkle:version">
                            <xsl:text>"</xsl:text>
                            <xsl:value-of select="enclosure/@sparkle:version" />
                            <xsl:text>";</xsl:text>
                        </xsl:when>
                        <xsl:when test="sparkle:version">
                            <xsl:text>"</xsl:text>
                            <xsl:value-of select="sparkle:version" />
                            <xsl:text>";</xsl:text>
                        </xsl:when>
                    </xsl:choose>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:text>"";</xsl:text>
                </xsl:otherwise>
            </xsl:choose>
            <xsl:choose>
                <xsl:when test="enclosure/@url or link">
                    <xsl:choose>
                        <xsl:when test="enclosure/@url">
                            <xsl:text>"</xsl:text>
                            <xsl:value-of select="enclosure/@url" />
                            <xsl:text>";</xsl:text>
                        </xsl:when>
                        <xsl:when test="link">
                            <xsl:text>"</xsl:text>
                            <xsl:value-of select="link" />
                            <xsl:text>";</xsl:text>
                        </xsl:when>
                    </xsl:choose>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:text>"";</xsl:text>
                </xsl:otherwise>
            </xsl:choose>
            <xsl:choose>
                <xsl:when test="title">
                    <xsl:text>"</xsl:text>
                    <xsl:value-of select="title" />
                    <xsl:text>";</xsl:text>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:text>""</xsl:text>
                </xsl:otherwise>
            </xsl:choose>
            <xsl:text>&#xa;</xsl:text>
        </xsl:for-each>
    </xsl:template>
</xsl:stylesheet>
EOF
)

  echo "${xls}" > "${TEMP_DIR}/${PROGRAM}_sparkle.xsl"

  transform=$(xmlstarlet tr "${TEMP_DIR}/${PROGRAM}_sparkle.xsl" <<< "${content}" 2> /dev/null)
  transform=$(sed -e 's/^[^"]*//g' -e 's/[^;]*$//g' <<< "${transform}")

  IFS=$'\n' read -rd '' -a lines <<< "${transform}"
  if [[ "${#lines[@]}" -gt 0 ]]; then
    readonly first=($(process_appcast_sparkle_line "${lines[0]}"))

    if [[ "${#lines[@]}" -gt 1 ]]; then
      readonly last=($(process_appcast_sparkle_line "${lines[${#lines[@]}-1]}"))

      compare_versions "${first[0]}" "${last[0]}"
      case $? in
        0) values=("${first[@]}") ;; # =
        1) values=("${first[@]}") ;; # >
        2) values=("${last[@]}") ;;  # <
      esac
    else
      values=("${first[@]}")
    fi
    readonly values

    echo "${values[@]}" && return 0
  else
    return 1
  fi
}

# Parse content of GitHub Atom appcast to extract all values.
#
# Globals:
#   GITHUB_USER
#   GITHUB_TOKEN
#   BROWSER_HEADERS
#   GITHUB_PRERELEASE
#
# Arguments:
#   $1 - Cask name
#   $2 - Content to parse
#   $3 - Match tag
#
# Returns array of values:
#   <prerelease>      (true|false)
#   <version>
#   <download_urls>   (array)
parse_appcast_github_latest() {
  local auth cask user repo match url out code content latest_tag prerelease_tag version prerelease download_urls
  local -a result

  [[ ! -z "${GITHUB_USER}" ]] && [[ ! -z "${GITHUB_TOKEN}" ]] && auth=(--user "${GITHUB_USER}:${GITHUB_TOKEN}")

  readonly cask="${1}"
  IFS='/' read -ra parts <<< "$2"
  readonly parts
  readonly user="${parts[3]}"
  readonly repo="${parts[4]}"
  readonly match="$3"

  readonly url="https://api.github.com/repos/${user}/${repo}/releases"
  readonly out=$(curl --silent --compressed --location "${url}" "${auth[@]}" --header "${BROWSER_HEADERS}" --max-time 10 --write-out '\n%{http_code}' 2>/dev/null)
  readonly code=$(echo "${out}" | tail -n1)
  readonly content=$(echo "${out}" | sed \$d)

  [[ "${code}" -eq 403 ]] && return 2

  if [[ ! -z "${match}" ]]; then
    latest_tag=$(echo "${content}" | jq ".|=sort_by(.created_at) | reverse | .[] | select(.prerelease == false) | .tag_name" 2> /dev/null | grep -i "${match}" | head -1 | xargs)
    prerelease_tag=$(echo "${content}" | jq ".|=sort_by(.created_at) | reverse | .[] | select(.prerelease == true) | .tag_name" 2> /dev/null | grep -i "${match}" | head -1 | xargs)
  fi

  if [[ -z "${latest_tag}" ]] && [[ -z "${prerelease_tag}" ]]; then
    latest_tag=$(echo "${content}" | jq ".|=sort_by(.created_at) | reverse | .[] | select(.prerelease == false) | .tag_name" 2> /dev/null | head -1 | xargs)
    prerelease_tag=$(echo "${content}" | jq ".|=sort_by(.created_at) | reverse | .[] | select(.prerelease == true) | .tag_name" 2> /dev/null | head -1 | xargs)
  fi

  readonly latest_tag prerelease_tag

  version="${latest_tag}"
  compare_versions "${latest_tag}" "${prerelease_tag}"
  [[ "$?" -eq 2 ]] && [[ "${GITHUB_PRERELEASE}" == 'true' ]] && version="${prerelease_tag}" # if latest_tag < prerelease_tag

  [[ -z "${version}" ]] && return 1

  prerelease='false'
  [[ "${version}" == "${prerelease_tag}" ]] && prerelease='true'

  readonly download_urls=($(echo "${content}" | jq ".[] | select(.tag_name == \"${latest_tag}\") | .assets" | jq '.[] | .browser_download_url' 2> /dev/null | xargs))
  version=$(grep -q 'v[0-9]' <<< "${version}" && echo "${version/v}" || echo "${version}") # v3.0 => 3.0
  grep -iq "${cask}" <<< "${version}" && version=$(tr '[:upper:]' '[:lower:]' <<< "${latest_tag}" | sed "s/^${cask}-//") # <caskname>-3.0 => 3.0
  result+=("${prerelease}")
  result+=("${version}")
  result+=("${download_urls[@]}")

  echo "${result[@]}"
}

# Guess the appcast provider from the content.
#
# Arguments:
#   $1 - Content
#
# Returns provider.
get_appcast_provider() {
  local content result

  readonly content="$1"

  # GitHub
  [[ "${content}" =~ '<feed'.*'<id>tag:github.com' ]] && result='GitHub Atom'

  # RSS
  if [[ "${content}" =~ '<rss'.* ]]; then
    # Sparkle
    [[ "${content}" =~ '<rss'.*'xmlns:sparkle' ]] && result='Sparkle'
    [[ "${content}" =~ '<item'.*'<enclosure' ]] && result='Sparkle'
  fi

  echo "${result}"

  [[ -z "${result}" ]] && return 1 || return 0
}

# Extract version number with download URL/URLs from appcast content.
#
# Globals:
#   CASKS_MATCHING_TAG
#
# Arguments:
#   $1 - Cask name (required)
#   $2 - URL       (required)
#   $3 - Content   (not required)
#
# Returns version.
get_appcast_version_with_downloads() {
  local cask url content out code values version download_url tag

  readonly cask="$1"
  readonly url="$2"

  content="$3"
  if [[ -z "$3" ]]; then
    readonly out=$(get_url_content "${url}")
    readonly code=$(echo "${out}" | tail -n1)
    content=$(echo "${out}" | sed \$d)
  fi
  readonly content

  case "$(get_appcast_provider "${content}")" in
    'Sparkle')
      readonly values=($(parse_appcast_sparkle_latest "${content}"))
      version="${values[0]}"
      if [[ "${#values[@]}" -eq 3 ]]; then
        [[ "${values[0]}" != "${values[1]}" ]] && version="${values[0]},${values[1]}"
        download_url="${values[2]}"
      else
        download_url="${values[1]}"
      fi
      echo "${version} ${download_url}" && return 0
    ;;
    'GitHub Atom')
      tag=''
      for i in "${!CASKS_MATCHING_TAG[@]}"; do
        if [[ $((i%2)) -ne 0 ]]; then
          key="${CASKS_MATCHING_TAG[$i-1]}"
          value="${CASKS_MATCHING_TAG[$i]}"

          [[ "${key}" == "${cask}" ]] && tag="${value}"
        fi
      done

      readonly values=($(parse_appcast_github_latest "${cask}" "${url}" "${tag}"))
      [[ ! -z "${values[1]}" ]] && echo "${values[1]}" && return 0
    ;;
  esac

  return 1
}

# Interpolate version into string.
#
# Arguments:
#   $1 - String
#   $2 - Version
#
# Returns string with version.
interpolate_version() {
  local IFS version_original version_only major minor patch string string_part version_part replace
  local -a string_parts version_parts

  string="$1"
  readonly version_original="$2"
  readonly version_only=$(sed -e 's/[^0-9.]*\([0-9.]*\).*/\1/' <<< "${version_original}")
  readonly string_parts=($(grep -o "#{version[^}]*}" <<< "${string}" | xargs))

  for string_part in "${string_parts[@]}"; do
    if [[ "${string_part}" == '#{version}' ]]; then
      string="${string//${string_part}/${version_original}}"
      continue
    fi

    IFS='.' read -ra version_parts <<< "$(sed -e 's/^#{version//' -e 's/}$//' -e 's/^\.//' <<< "${string_part}")"

    for version_part in "${version_parts[@]}"; do
      replace=''
      major=$(cut -d '.' -f 1 <<< "${version_only}")
      minor=$(cut -d '.' -f 2 <<< "${version_only}")
      patch=$(cut -d '.' -f 3 <<< "${version_only}")

      case "${version_part}" in
        'major')             replace+="${major}" ;;
        'minor')             replace+="${minor}" ;;
        'patch')             replace+="${patch}" ;;
        'major_minor')       replace+="${major}.${minor}" ;;
        'major_minor_patch') replace+="${major}.${minor}.${patch}" ;;
        'before_comma')      replace+="$(cut -d ',' -f 1 <<< "${version_original}")" ;;
        'after_comma')       replace+="$(cut -d ',' -f 2 <<< "${version_original}")" ;;
        'before_colon')      replace+="$(cut -d ':' -f 1 <<< "${version_original}")" ;;
        'after_colon')       replace+="$(cut -d ':' -f 2 <<< "${version_original}")" ;;
      esac
    done

    string="${string//${string_part}/${replace}}"
  done

  echo "${string}"
}

# Suggest version to use in casks download URL.
#
# Globals:
#   CASKS_VERSION_DELIMETER_BUILD
#
# Arguments:
#   $1 - Cask name
#   $2 - Current version
#   $4 - Latest version
#   $5 - Latest download URL
#
# Returns suggested version.
suggest_cask_version() {
  local cask version latest_version latest_build latest_download_url result devmate_version devmate_part amazonaws_part hackplan_part delimeter

  cask="$1"
  version="$2"
  latest_version="$(cut -d ',' -f 1 <<< "$3")"
  latest_build="$(cut -d ',' -f 2 <<< "$3")"
  latest_download_url=$(interpolate_version "$4" "$3")

  [[ "${latest_version}" == "${latest_build}" ]] && latest_build=''

  delimeter=$(sed -e 's/[A-Za-z0-9.]//g' <<< "${version}") # try guessing the delimeter from old version
  [[ -z "${delimeter}" ]] && delimeter='.'
  [[ "${#delimeter}" -ne 1 ]] && delimeter=','

  result="${latest_version}"
  # [[ ! -z "${latest_build}" ]] && result="${latest_version}${delimeter}${latest_build}" || result="${latest_version}"

  # dl.devmate.com
  if [[ "${latest_download_url}" =~ dl.devmate.com ]] || [[ "${latest_download_url}" =~ dl.smilesoftware.com ]]; then
    devmate_version="$(cut -d '/' -f 5 <<< "${latest_download_url}")"
    devmate_part="$(cut -d '/' -f 6 <<< "${latest_download_url}")"

    if [[ "${#devmate_part}" -eq 10 ]]; then
      if [[ ! -z "${latest_build}" ]] && [[ "${devmate_version}" == "${latest_build}" ]]; then
        result="${latest_version},${latest_build}:${devmate_part}"
      else
        result="${latest_version}${delimeter}${devmate_part}"
      fi
    fi
  fi

  # amazonaws.com
  if [[ "${latest_download_url}" =~ amazonaws.com ]]; then
    amazonaws_part="$(cut -d '/' -f 6 <<< "${latest_download_url}")"
  fi

  # cdn.hackplan.com
  if [[ "${latest_download_url}" =~ cdn.hackplan.com ]]; then
    hackplan_part="$(cut -d '/' -f 5 <<< "${latest_download_url}")"
  fi

  # cask specific
  case "${cask}" in
    'automatic')            result="${latest_version}.${latest_build}" ;;
    'boxcryptor')           result="${latest_version}.${latest_build}" ;;
    'cockatrice')           result="${latest_version%%-Release}" ;;
    'cyberduck')            result="${latest_version}.${latest_build}" ;;
    'daemon-tools-lite')    result="${latest_build}" ;;
    'darktable')            result="${latest_version//release-}" ;;
    'disablemonitor')       result="${latest_version//G}" ;;
    'favs')                 result="${latest_version//.}" ;;
    'festify')              result="${latest_version%%beta}" ;;
    'flixster-video')       result="${latest_version//-v*}" ;;
    'framer')               result="${latest_version}" ;;
    'goldencheetah')        result="${latest_version//V}" ;;
    'iterm2-nightly')       result="${latest_version%%-nightly}" ;;
    'macvim')               result="7.4.${latest_version//snapshot-}" ;;
    'marked')               result="${latest_version}${latest_build}" ;;
    'master-key')           result="${latest_build}" ;;
    'monodraw')             result="b${latest_build}" ;;
    'mountain-duck')        result="${latest_version}.${latest_build}" ;;
    'nvalt')                result="${latest_version}${latest_build}" ;;
    'openra')               result="${latest_version//release-}" ;;
    'osxfuse-beta')         result="${latest_version//osxfuse-}" ;;
    'pdfpen')               result="${latest_build}${delimeter}${devmate_part}" ;;
    'pdfpenpro')            result="${latest_build}${delimeter}${devmate_part}" ;;
    'pomotodo')             result="${latest_version}${delimeter}${hackplan_part}" ;;
    'propresenter')         result="${latest_version}${delimeter}b${latest_build}" ;;
    'qblocker')             result="${latest_build}${delimeter}${devmate_part}" ;;
    'qlcolorcode')          result="${latest_version//release-}" ;;
    'qldds')                result=$(sed -e "s/.\{1\}/&./" <<< "${latest_version//rel-}") ;;
    'qlvideo')              result=$(sed -e "s/.\{1\}/&./" <<< "${latest_version//rel-}") ;;
    'querious')             result="${latest_version//b/_beta}" ;;
    'quickradar')           result="${latest_version//beta/b}" ;;
    'sequel-pro')           result="${latest_version//release-}" ;;
    'shiftit')              result="${latest_version//version-}" ;;
    'snapheal-pro')         result="${latest_version}.${latest_build}" ;;
    'soundflowerbed')       result="${latest_version%%-release}" ;;
    'spillo')               result="${latest_build}${delimeter}${latest_version}" ;;
    'sshfs')                result="${latest_version//osxfuse-sshfs-}" ;;
    'subtitle-master')      result="${latest_version%%-SNAPSHOT}" ;;
    'supercollider')        result="${latest_version//Version-}" ;;
    'textexpander')         result="${latest_build}${delimeter}${devmate_part}" ;;
    'time-tracker')         result="${latest_version%%-binary}" ;;
    'tower-beta')           result="${latest_version}-${latest_build}${delimeter}${amazonaws_part}" ;;
    'vox')                  result="${latest_build}${delimeter}${devmate_part}" ;;
    'vox-preferences-pane') result="${latest_build}${delimeter}${devmate_part}" ;;
    'xld')                  result=$(sed -e "s/.\{4\}/&./" -e "s/.\{7\}/&./" <<< "${latest_version}") ;;
  esac

  # "<version><delimeter><build>"
  for cask_vb in "${CASKS_VERSION_DELIMETER_BUILD[@]}"; do
    [[ "${cask}" == "${cask_vb}" ]] && result="${latest_version}${delimeter}${latest_build}"
  done

  echo "${result}"
}

# Add info to review.
#
# Globals:
#   REVIEW
#
# Arguments:
#   $1 - Name
#   $2 - Value
add_to_review() {
  local name
  [[ ! -z "$1" ]] && name="$1:" || name="$1"
  REVIEW+=("$(printf "%-17s %s" "${name}" "$2")")
}

# Show review.
#
# Globals:
#   REVIEW
show_review() {
  [[ "${#REVIEW[@]}" -gt 0 ]] && printf '%s\n' "${REVIEW[@]}"
}

# Review cask versions.
#
# Globals:
#   SHOW_ALL
#
# Arguments:
#   $1 - Cask name
review_cask_versions() {
  local -a versions appcasts checkpoints urls latest
  local -i versions_max_length appcasts_counter i status
  local cask values line version appcast checkpoint url out code content latest_checkpoint latest_version suggested_version suggested_latest_version latest_url review_name review_value

  readonly cask="$1"
  readonly values=$(get_cask_version_appcast_checkpoint_url "${cask}")

  IFS=$'\n' read -rd '' -a lines <<< "${values}"

  for line in "${lines[@]}"; do
    line=($(echo "${line}" | xargs))
    version="${line[0]}"
    appcast=$(interpolate_version "${line[1]}" "${version}")
    checkpoint="${line[2]}"
    url="${line[3]}"

    [[ -z "${version}" ]] && continue

    [[ "${versions_max_length}" -lt "${#version}" ]] && versions_max_length="${#version}"
    versions+=("${version}")
    appcasts+=("${appcast}")
    checkpoints+=("${checkpoint}")
    urls+=("${url}")

    [[ "${#line[@]}" -lt 3 ]] && continue
    [[ -z "${appcast}" ]] && continue
    ((appcasts_counter++))
  done

  for ((i = 0; i < ${#versions[@]}; i++)); do
    version="${versions[i]}"
    appcast="${appcasts[i]}"
    checkpoint="${checkpoints[i]}"
    url="${urls[i]}"

    if [[ "${i}" -eq 0 ]]; then
      review_name='Cask version'
      [[ "${appcasts_counter}" -gt 1 ]] && review_name+='s'
    else
      review_name=''
    fi

    review_value=$(printf "%-${versions_max_length}s" "${version}")

    if [[ ! -z "${appcast}" ]] && [[ ! -z "${checkpoint}" ]]; then
      out=$(get_url_content "${appcast}")
      code=$(echo "${out}" | tail -n1)
      content=$(echo "${out}" | sed \$d)

      latest=($(get_appcast_version_with_downloads "${cask}" "${appcast}"))
      status="$?"
      latest_checkpoint="$(generate_appcast_checkpoint "${content}")"
      latest_version="${latest[0]}"
      latest_url="${latest[1]}"

      suggested_version=$(suggest_cask_version "${cask}" "${version}" "${version}" "${url}")
      suggested_latest_version=$(suggest_cask_version "${cask}" "${version}" "${latest_version}" "${latest_url}")

      if [[ "${latest_checkpoint}" == "${checkpoint}" ]] && [[ "${status}" -eq 0 ]]; then
        review_value+=" | ${latest_version}"
        if [[ "${latest_version}" != "${suggested_latest_version}" ]]; then
          review_value+=" → $(tput setaf 7)${suggested_latest_version}$(tput sgr0)"
        fi
        [[ "${SHOW_ALL}" == 'true' ]] && output_csv "${cask}" "${appcast}" "${version}" "${latest_version}" "${suggested_latest_version}"
      elif [[ "${status}" -eq 0 ]]; then
        if [[ "${latest_version}" =~ ${version} ]] || [[ "${version}" =~ ${latest_version} ]]; then
          review_value+=" | ${latest_version}"
          if [[ "${latest_version}" != "${suggested_version}" ]]; then
            review_value+=" → $(tput setaf 7)${suggested_version}$(tput sgr0)"
          fi
          [[ "${SHOW_ALL}" == 'true' ]] && output_csv "${cask}" "${appcast}" "${version}" "${latest_version}" "${suggested_version}"
        else
          show='true'
          review_value+=" | $(tput setaf 2)${latest_version}$(tput sgr0)"
          if [[ "${latest_version}" != "${suggested_latest_version}" ]]; then
            review_value+=" → $(tput setaf 2)${suggested_latest_version}$(tput sgr0)"
          fi
          review_value+=" (latest)"
          output_csv "${cask}" "${appcast}" "${version}" "${latest_version}" "${suggested_latest_version}"
        fi
      else
        review_value+=" | -"
      fi
    else
      review_value+=" | -"
    fi

    add_to_review "${review_name}" "${review_value}"
  done
}

# Review cask appcasts.
#
# Arguments:
#   $1 - Cask name
#   $2 - Appcast
#   $3 - Current version
#   $4 - Latest version
review_cask_appcasts() {
  local -a appcasts checkpoints
  local -i appcasts_max_length i
  local cask values version appcast checkpoint out code content latest_checkpoint latest_version review_name review_value status

  readonly cask="$1"
  readonly values=$(get_cask_version_appcast_checkpoint_url "${cask}")

  IFS=$'\n' read -rd '' -a lines <<< "${values}"

  for line in "${lines[@]}"; do
    line=($(echo "${line}" | xargs))
    version="${line[0]}"
    appcast=$(interpolate_version "${line[1]}" "${version}")
    checkpoint="${line[2]}"

    [[ "${#line[@]}" -lt 3 ]] && continue
    [[ -z "${appcast}" ]] && continue

    [[ "${appcasts_max_length}" -lt "${#appcast}" ]] && appcasts_max_length="${#appcast}"
    appcasts+=("${appcast}")
    checkpoints+=("${checkpoint}")
  done

  for ((i = 0; i < ${#appcasts[@]}; i++)); do
    appcast="${appcasts[i]}"
    checkpoint="${checkpoints[i]}"

    out=$(get_url_content "${appcast}")
    code=$(echo "${out}" | tail -n1)
    content=$(echo "${out}" | sed \$d)

    if [[ "${code}" -eq 000 ]] && [[ "${appcast}" =~ 'https' ]]; then
      appcast="${appcast/https/http}"

      out=$(get_url_content "${appcast}")
      code=$(echo "${out}" | tail -n1)
      content=$(echo "${out}" | sed \$d)

      [[ "${appcasts_max_length}" -eq "$((${#appcast}+1))" ]] && ((appcasts_max_length--))
    fi

    latest_checkpoint="$(generate_appcast_checkpoint "${content}")"

    [[ "${i}" -eq 0 ]] && review_name='Cask appcast' || review_name=''
    [[ "${i}" -eq 0 ]] && [[ "${#appcasts[@]}" -gt 1 ]] && review_name+='s'

    review_value=$(printf "%-$((appcasts_max_length+6))s" "${appcast} (${code})")

    if [[ "${code}" -eq 200 ]]; then
      if [[ "${latest_checkpoint}" == "${checkpoint}" ]]; then
        status="$(tput setaf 2)valid$(tput sgr0) (${checkpoint:0:6}...)"
        review_value+=$(printf " %s" "| ${status}")
      else
        status="$(tput setaf 3)outdated checkpoint$(tput sgr0) (${checkpoint:0:6}... => $(tput setaf 7)${latest_checkpoint:0:6}$(tput sgr0)...)"
        review_value+=$(printf " %s" "| ${status}")
      fi
    else
      status="$(tput setaf 1)error ${code}$(tput sgr0)"
      review_value+=$(printf " %s" "| ${status}")
    fi

    add_to_review "${review_name}" "${review_value}"
  done
}

# Append new line to CSV file.
#
# Globals:
#   OUTPUT
#   OUTPUT_PATH
#
# Arguments:
#   $1 - Cask name
#   $2 - Appcast
#   $3 - Current version
#   $4 - Latest version
#   $5 - Suggested latest version
output_csv() {
  [[ "${OUTPUT}" == 'true' ]] && printf "\"%s\";\"%s\";\"%s\";\"%s\";\"%s\"\n" "$1" "$2" "$3" "$4" "$5" >> "${OUTPUT_PATH}"
}

# Globals:
#   SHOW_CHECKPOINTS
#   REVIEW
#
# Arguments:
#   $1 - Cask
main() {
  local cask show

  readonly cask="$1"
  show='false'

  add_to_review 'Cask name' "$(tput setaf 7)${cask}$(tput sgr0)"

  review_cask_versions "${cask}"
  [[ "${SHOW_CHECKPOINTS}" == 'true' ]] && review_cask_appcasts "${cask}"

  [[ "${SHOW_ALL}" == 'true' ]] && show='true'
  [[ "${show}" == 'true' ]] && show_review
  REVIEW=()

  [[ "${show}" == 'true' ]] && [[ "${#CASKS[@]}" -gt 1 ]] && divide
}

# process
[[ "${#CASKS[@]}" -eq 0 ]] && CASKS=($(egrep -lir --include '*.rb' "(appcast ')" . | xargs -n1 basename | sed 's|\.rb$||' | sort))
[[ "${#CASKS[@]}" -gt 1 ]] && printf "Checking updates for %s casks...\n" "${#CASKS[@]}" && divide
[[ "${OUTPUT}" == 'true' ]] && printf "\"%s\";\"%s\";\"%s\";\"%s\";\"%s\"\n" 'Name' 'Appcast' 'Current version' 'Latest version' 'Suggested latest version' > "${OUTPUT_PATH}"
for cask in "${CASKS[@]}"; do main "${cask}"; done

exit 0
